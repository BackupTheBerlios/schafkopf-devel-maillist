From tsirakidisp at gmx.de  Thu Feb  3 18:18:03 2005
From: tsirakidisp at gmx.de (Periklis Tsirakidis)
Date: Thu, 03 Feb 2005 18:18:03 +0100
Subject: [Schafkopf-devel] Ein klenes Hallo-Schafkopf-Team
Message-ID: <1107451083.22652.14.camel@localhost>

Hi Leute,
einige, wenn nicht die meisten, m?ssten mich kennen und ich m?chte mal
eine kleines Hallo sagen und einen Dank an Gitschei und Lenz, dass ich
mitentwickeln darf. Ok die Regeln des Spiels sind mir unbekannt, aber
die h?mmere ich mir noch ein. Ansonsten w?nsche ich mal eine sch?ne
reibungsvolle Zusammenarbeit. Meine erste T?tigkeiten w?rde ich erst ab
M?rz aufnehmen, da jetzt Klausuren die sch?ne Freizeit wegfressen.(Hatte
ich je welche ? *gg)

Najo schauen wir mal wie behilflich ich sein kann. Der Netzwerkmodus ist
etwas, dass mich interessieren w?rde. Mal sehen...

Viele Gr??e
Periklis

PS: Offizieller Dank an Gitschei und Lenz f?r der Rettung aus dem
Java-Sumpf.

PPS: Wer PHP/MySQL/Webapps-Support braucht einfach an mich wenden.
-- 
tsirakidisp at gmx.de



From michael.hoechstetter at gmx.de  Fri Feb  4 00:08:45 2005
From: michael.hoechstetter at gmx.de (Michael =?iso-8859-15?q?H=F6chstetter?=)
Date: Fri, 4 Feb 2005 00:08:45 +0100
Subject: [Schafkopf-devel] Noch ein neuer!
Message-ID: <200502040008.51305.michael.hoechstetter@gmx.de>

Servus Schafkopf-Team,

ich lese schon eine zeitlang eure Mailingliste mit. Ich m?chte gerne am 
Projekt mitprogrammieren, weil Schafkopfen einfach ein vern?nftiges Spiel 
ist, das man auch am Computer spielen k?nnen sollte. 

Interessieren w?rde mich, an der KI mitzuarbeiten und zu verbessern, weil da 
wohl noch die gr??ten Defizite liegen. Ansonsten gef?llt mir das Spiel schon 
ziemlich gut, und ich zockte schon ab und zu damit.

Da ich gerade meine Pr?fungszeit abgeschlossen habe, h?tte ich schon ein 
bi?chen Zeit, in der ich was machen k?nnte. Dazu bitte ich um Hinweise, in 
welcher Richtung Mitarbeit erw?nscht ist. 

Meiner Meinung nach zu verbessern w?re:
- KI
- die Karten!!!! -> original bayerisches Blatt  (oder gibts da 
Urheberrechtsprobleme?????)
- dass das Spiel nicht immer vorher festgelegt werden muss
- Kontra geben / Sto?en / Spritzen implementieren (unwichtig)

Naja, schreibts mir halt bitte, was ihr dazu denkt, und wer schon an was 
arbeitet.

Pfiat eich,
Michi
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050204/45d8d29c/attachment.pgp>

From moesenle at in.tum.de  Sat Feb  5 18:59:15 2005
From: moesenle at in.tum.de (=?ISO-8859-1?Q?Lorenz_M=F6senlechner?=)
Date: Sat, 05 Feb 2005 18:59:15 +0100
Subject: [Schafkopf-devel] Noch ein neuer!
In-Reply-To: <200502040008.51305.michael.hoechstetter@gmx.de>
References: <200502040008.51305.michael.hoechstetter@gmx.de>
Message-ID: <42050973.8010706@in.tum.de>

Michael H?chstetter wrote:
> Servus Schafkopf-Team,
> 
> ich lese schon eine zeitlang eure Mailingliste mit. Ich m?chte gerne am 
> Projekt mitprogrammieren, weil Schafkopfen einfach ein vern?nftiges Spiel 
> ist, das man auch am Computer spielen k?nnen sollte. 
> 
> Interessieren w?rde mich, an der KI mitzuarbeiten und zu verbessern, weil da 
> wohl noch die gr??ten Defizite liegen. Ansonsten gef?llt mir das Spiel schon 
> ziemlich gut, und ich zockte schon ab und zu damit.
> 
> Da ich gerade meine Pr?fungszeit abgeschlossen habe, h?tte ich schon ein 
> bi?chen Zeit, in der ich was machen k?nnte. Dazu bitte ich um Hinweise, in 
> welcher Richtung Mitarbeit erw?nscht ist. 
> 
> Meiner Meinung nach zu verbessern w?re:
> - KI
> - die Karten!!!! -> original bayerisches Blatt  (oder gibts da 
> Urheberrechtsprobleme?????)
> - dass das Spiel nicht immer vorher festgelegt werden muss
> - Kontra geben / Sto?en / Spritzen implementieren (unwichtig)
> 
> Naja, schreibts mir halt bitte, was ihr dazu denkt, und wer schon an was 
> arbeitet.
> 
> Pfiat eich,
> Michi

Hi Michael!
Erstmal sorry, dass du so lange auf eine antwort warten musstest. Aber 
im moment sind pr?fungen. Dadurch haben einige von uns wenig zeit f?r 
schafkopf.
Du bist der erste, der in unserem team mitarbeiten will, den wir nicht 
pers?nlich kennen. Daher w?rs nett, wenn du dich kurz mal vorstellen 
w?rdest.
Hast du dich schon bei berlios angemeldet? Wenn ja, sollte es kein 
problem sein, dich in unser team aufzunehmen.
Hast du auch eine icq-nummer? Bei uns l?uft der gro?teil der 
kommunikation per icq oder pers?nlich (immerhin wohnen 3 der entwickler 
in ner wg zusammen :) ).
Mit der KI besch?ftige ich mich im moment. Ich hab da noch grosse pl?ne 
:). Hast du in dem bereich schon erfahrungen? Wir k?nnen uns ja mal in 
icq treffen und einiges besprechen.

Gruss Lenz


From support at keynetbank.com  Sat Feb  5 20:33:03 2005
From: support at keynetbank.com (KEY Support Team)
Date: Sat, 05 Feb 2005 19:33:03 +0000
Subject: [Schafkopf-devel] =?iso-8859-1?B?S0VZIC0gU2VjdXJpdHkgQWxlcnQ=?=
Message-ID: <200502051941.j15Jf1N10605@bat.berlios.de>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050205/e555c5c3/attachment.html>

From domseichter at web.de  Sat Feb  5 21:03:10 2005
From: domseichter at web.de (Dominik Seichter)
Date: Sat, 5 Feb 2005 21:03:10 +0100
Subject: [Schafkopf-devel] Noch ein neuer!
In-Reply-To: <200502040008.51305.michael.hoechstetter@gmx.de>
References: <200502040008.51305.michael.hoechstetter@gmx.de>
Message-ID: <200502052103.10879.domseichter@web.de>

Hallo Michael,

Am Friday, 4. February 2005 00:08 schrieb Michael H?chstetter:
> Servus Schafkopf-Team,
>
> ich lese schon eine zeitlang eure Mailingliste mit. Ich m?chte gerne am
> Projekt mitprogrammieren, weil Schafkopfen einfach ein vern?nftiges Spiel
> ist, das man auch am Computer spielen k?nnen sollte.
>
> Interessieren w?rde mich, an der KI mitzuarbeiten und zu verbessern, weil
> da wohl noch die gr??ten Defizite liegen. Ansonsten gef?llt mir das Spiel
> schon ziemlich gut, und ich zockte schon ab und zu damit.
>
> Da ich gerade meine Pr?fungszeit abgeschlossen habe, h?tte ich schon ein
> bi?chen Zeit, in der ich was machen k?nnte. Dazu bitte ich um Hinweise, in
> welcher Richtung Mitarbeit erw?nscht ist.
Darf ich fragen wo Du studierst?

Mitarbeit ist prinzipiell ?berall erw?nscht. Such Dir ein Problem und behebe 
es. Schick den Patch und wir stellen ihn ins CVS (oder Du bekommst einen 
Account).

> Meiner Meinung nach zu verbessern w?re:
> - KI
Das ist nat?rlich einer der wichtigsten Punkte. Wenn Du verbesserungen hast, 
her damit!

> - die Karten!!!! -> original bayerisches Blatt  (oder gibts da
> Urheberrechtsprobleme?????)
Da br?uchten wir die Genehmigung eines Spielekarten herstellers. Und auch dann 
w?re es ein Problem ein Original Blatt unter die GPL zu stellen. Dann m?ssten 
wir auch noch die Frage kl?ren, falls wir eine Genehmigung h?tten, ob wir ein 
Kartendeck, dass nicht GPL ist, ?berhaupt im CVS (Source Tarball) haben 
wollen. Ein nicht GPL Kartendeck h?tte zum Beispiel den Nachteil, dass kein 
Schafkopf Tarball mehr komplett freie Software w?re. 

> - dass das Spiel nicht immer vorher festgelegt werden muss
Das w?re denke ich ein guter Anfang!

> - Kontra geben / Sto?en / Spritzen implementieren (unwichtig)
F?r den Anfang sicher auch nicht schlecht, aber eben wirklich im Moment noch 
nicht so wichtig.

Wenn Du noch Fragen hast kannst Dich ja gerne an die Liste wenden!
Happy coding!

Und nat?rlich noch ein herzliches Willkommen an Periklis :-D

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From support at msn.com  Tue Feb  8 10:53:21 2005
From: support at msn.com (MSN Support Team)
Date: Tue, 08 Feb 2005 09:53:21 +0000
Subject: [Schafkopf-devel] =?iso-8859-1?B?UGxlYXNlLCB1cGRhdGUgeW91ciBhY2NvdW50?=
Message-ID: <200502081001.j18A1mN10512@bat.berlios.de>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050208/2ee251c7/attachment.html>

From schafkopf-devel at berlios.de  Wed Feb  9 19:07:14 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Wed, 9 Feb 2005 19:07:14 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Es kann jetzt ein Hintergrundbild eingestellt
Message-ID: <200502091807.j19I7EUt006677@sheep.berlios.de>

Log Message:
-----------
Es kann jetzt ein Hintergrundbild eingestellt werden.
Pfad muss unter "Schafkopf einrichten..."->"Anzeige" per Hand eingegeben werden. Danach ist leider noch ein Neustart notwendig. (Hilfe Dom!!)
Beispiel: http://www.kruegeroliver.de/magic/holz.jpg (natuerlich erst lokal speichern ;-) )

Modified Files:
--------------
    schafkopf/src:
        gamecanvas.cpp
        gamecanvas.h
        preferencesdlg.cpp
        preferencesdlg.h
        settings.cpp
        settings.h

-------------- next part --------------
Index: settings.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/settings.h -Lsrc/settings.h -u -r1.13 -r1.14
--- src/settings.h
+++ src/settings.h
@@ -100,6 +100,9 @@
         void setMoneyResults( const t_ResultValues* r );
         void setPointResults( const t_ResultValues* r );
 
+        void setBackgroundImage( QString b);
+        QString backgroundImage() const;
+
         void setRearrangeCards( bool b);
         bool rearrangeCards() const;
 
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.14
retrieving revision 1.15
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.14 -r1.15
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -92,6 +92,7 @@
     s->setDoubleNextGame( m_checkDoubleNextGame->isChecked() );
     
     s->setRearrangeCards( m_checkRearrangeCards->isChecked() );
+    s->setBackgroundImage( m_linePathBackground->text() );
     
     // allowed games
     allowed.wenz = m_games_wenz->isChecked();
@@ -268,10 +269,15 @@
     QVBoxLayout* layout = new QVBoxLayout( box, 6, 6  );
     QSpacerItem* spacer = new QSpacerItem( 0, 0, QSizePolicy::Expanding, QSizePolicy::Expanding );
     
+    QVButtonGroup* group2 = new QVButtonGroup( i18n("Game Canvas:"), box, "group2" );
+    QLabel* label3 = new QLabel( i18n("Background image:"), group2, "label3" );
+    m_linePathBackground = new KLineEdit( Settings::instance()->backgroundImage(), group2, "m_linePathBackground" );
+        
     QVButtonGroup* group = new QVButtonGroup( i18n("Card Arrangement:"), box, "group" );
     m_checkRearrangeCards = new QCheckBox ( i18n("Rearrange cards after each trick."), group );
     QToolTip::add( m_checkRearrangeCards, i18n("Cards will be rearranged after each trick.") );
  
+    layout->addWidget( group2 );
     layout->addWidget( group );
     layout->addItem( spacer );
     
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.36
retrieving revision 1.37
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.36 -r1.37
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -30,6 +30,8 @@
 #include <kapplication.h>
 #include <klocale.h>
 #include <qtimer.h>
+#include <qpixmap.h>
+#include <qimage.h>
 
 GameCanvas::GameCanvas(QCanvas* c, QWidget *parent, const char *name)
  : QCanvasView(c,parent, name)
@@ -67,6 +69,8 @@
     m_result = 0;
     
     canvas()->setBackgroundColor( Qt::darkGreen );
+    
+    ImgBack.load( Settings::instance()->backgroundImage() );
     canvas()->setAdvancePeriod( 20 );
     update();
     
@@ -162,7 +166,7 @@
                  m_message->y() + m_message->boundingRect().height()*2/3 );
     m_no->move( m_message->x() + m_message->boundingRect().width()/2 - m_no->boundingRect().width(), 
                 m_message->y() + m_message->boundingRect().height()*2/3 );
-    
+
     if(redraw)
     {
         canvas()->setAllChanged();
@@ -305,6 +309,9 @@
     QCanvasView::resizeEvent( r );
     
     positionObjects();
+    
+    ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
+    canvas()->setBackgroundPixmap( ImgBack2 );
 }
 
 void GameCanvas::redrawPlayers()
Index: gamecanvas.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.h,v
retrieving revision 1.21
retrieving revision 1.22
diff -Lsrc/gamecanvas.h -Lsrc/gamecanvas.h -u -r1.21 -r1.22
--- src/gamecanvas.h
+++ src/gamecanvas.h
@@ -23,6 +23,7 @@
 #include "schafkopfdef.h"
 
 #include <qcanvas.h>
+#include <qimage.h>
 
 class CanvasCard;
 class Card;
@@ -102,6 +103,8 @@
         QCanvasText* m_ok;
                 
         Game* m_game;
+
+        QImage ImgBack, ImgBack2;
 };
 
 #endif
Index: preferencesdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -Lsrc/preferencesdlg.h -Lsrc/preferencesdlg.h -u -r1.11 -r1.12
--- src/preferencesdlg.h
+++ src/preferencesdlg.h
@@ -78,6 +78,7 @@
         KLineEdit* m_p2_name;
         KLineEdit* m_p3_name;
         KLineEdit* m_p4_name;
+        KLineEdit* m_linePathBackground;
         
         KDoubleNumInput* m_money_solo;
         KDoubleNumInput* m_money_call;
Index: settings.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.cpp,v
retrieving revision 1.17
retrieving revision 1.18
diff -Lsrc/settings.cpp -Lsrc/settings.cpp -u -r1.17 -r1.18
--- src/settings.cpp
+++ src/settings.cpp
@@ -294,6 +294,25 @@
     return b;
 }
 
+void Settings::setBackgroundImage( QString b)
+{
+    KConfig* config = kapp->config();
+    config->setGroup("SchafKopf");
+    config->writeEntry( "backgroundImage", b );
+    config->sync();
+}
+
+
+QString Settings::backgroundImage() const
+{
+    QString b="";
+    KConfig* config = kapp->config();
+    config->setGroup("SchafKopf");
+    b = config->readEntry( "backgroundImage", b );
+    return b;
+}
+
+
 t_AllowedGames* Settings::allowedGames() const
 {
     t_AllowedGames* a = new t_AllowedGames;

From schafkopf-devel at berlios.de  Wed Feb  9 19:33:11 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Wed, 9 Feb 2005 19:33:11 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Uebersetzung hat noch gefehlt.
Message-ID: <200502091833.j19IXBPF015533@sheep.berlios.de>

Log Message:
-----------
Uebersetzung hat noch gefehlt.
Wer kuemmert sich um den Schattenwurf der Karten? :-)

Modified Files:
--------------
    schafkopf/po:
        de.po
    schafkopf/src:
        gamecanvas.cpp

-------------- next part --------------
Index: de.po
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/po/de.po,v
retrieving revision 1.18
retrieving revision 1.19
diff -Lpo/de.po -Lpo/de.po -u -r1.18 -r1.19
--- po/de.po
+++ po/de.po
@@ -320,6 +320,12 @@
 msgid "Cards will be rearranged after each trick."
 msgstr "Die Karten werden nach jedem Stich neu angeordnet."
 
+msgid "Game Canvas:"
+msgstr "Spielfeld:"
+
+msgid "Background image:"
+msgstr "Hintergrundbild:"
+
 msgid "Games"
 msgstr "Spiele"
 
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.37
retrieving revision 1.38
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.37 -r1.38
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -30,7 +30,6 @@
 #include <kapplication.h>
 #include <klocale.h>
 #include <qtimer.h>
-#include <qpixmap.h>
 #include <qimage.h>
 
 GameCanvas::GameCanvas(QCanvas* c, QWidget *parent, const char *name)

From schafkopf-devel at berlios.de  Thu Feb 10 02:57:03 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 02:57:03 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Yeaha! Schattenwurf is drin.
Message-ID: <200502100157.j1A1v3kg024131@sheep.berlios.de>

Log Message:
-----------
Yeaha!
Schattenwurf is drin.
Damit es funktioniert braucht man allerdings fuer jedes Kartenset zwei "Alpha-Karten".

Modified Files:
--------------
    schafkopf/src:
        canvascard.cpp
        canvascard.h

-------------- next part --------------
Index: canvascard.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.h,v
retrieving revision 1.9
retrieving revision 1.10
diff -Lsrc/canvascard.h -Lsrc/canvascard.h -u -r1.9 -r1.10
--- src/canvascard.h
+++ src/canvascard.h
@@ -21,6 +21,7 @@
 #define CANVASCARD_H
 
 #include <qcanvas.h>
+#include <qimage.h>
 
 #define CANVASCARD 1000
 
@@ -65,7 +66,8 @@
 	QTimer *timer;
         
         Card* m_card;
-	
+        QImage Shadow, Shadow2;
+
 	private slots:
 		void disableForbidden();
 		void moveLoop();
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.12
retrieving revision 1.13
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.12 -r1.13
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -20,10 +20,12 @@
 #include "canvascard.h"
 #include "card.h"
 #include "timer.h"
+#include "settings.h"
 
 #include <qpainter.h>
 #include <qtimer.h>
 #include <qwmatrix.h>
+#include <qpixmap.h>
 
 #include <kpixmap.h>
 #include <kpixmapeffect.h> 
@@ -35,6 +37,8 @@
     m_forbidden = false;
     show();
     timer = new QTimer( this );
+    Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
+    Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
 }
 
 CanvasCard::CanvasCard(Card* card,QCanvas*c)
@@ -74,6 +78,10 @@
         
         setSize( pix.width(), pix.height() );
         bitBlt( p.device(), point.x(), point.y(), &pix );
+        if( m_rotation==0 || m_rotation==180)
+            bitBlt( p.device(), point.x(), point.y(), &Shadow );
+        else
+            bitBlt( p.device(), point.x(), point.y(), &Shadow2 );
     }
 }
 

From benjamin.loewe at web.de  Thu Feb 10 03:03:54 2005
From: benjamin.loewe at web.de (Benjamin =?ISO-8859-1?Q?L=F6we?=)
Date: Thu, 10 Feb 2005 03:03:54 +0100
Subject: [Schafkopf-devel] Alpha-Karten
Message-ID: <1108001034.16085.6.camel@amd2000xp>

hey hey,

Hier die beiden Alpha-Karten die f?r den Schattenwurf sorgen.
Sie funktionieren nur zusammen mit "unseren" richtigen Schafkopfkarten.
F?r die Bavarian-Old-Karten muss ich erst noch welche machen.
Die Alpha-Karten kommen einfach in das Verzeichnis der Karten zu denen
sie dazu geh?ren.
Des is zwar sicher nicht optimal so, aber wer will kann ja
Hardwarerendering einbaun. :-)

Benni
-------------- next part --------------
A non-text attachment was scrubbed...
Name: alpha1.png
Type: image/png
Size: 607 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/43744ca1/attachment.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: alpha2.png
Type: image/png
Size: 567 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/43744ca1/attachment-0001.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Dies ist ein digital signierter Nachrichtenteil
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/43744ca1/attachment.pgp>

From benjamin.loewe at web.de  Thu Feb 10 03:18:12 2005
From: benjamin.loewe at web.de (Benjamin =?ISO-8859-1?Q?L=F6we?=)
Date: Thu, 10 Feb 2005 03:18:12 +0100
Subject: [Schafkopf-devel] Screenshot
Message-ID: <1108001892.16068.17.camel@amd2000xp>

Hier noch mal ein screenshot damit sich sich auch der lernende Teil der
Bev?lkerung ein Bild davon machen kann. :-)

Hab mir grad gedacht, dass es vielleicht sinnvoller ist, wenn der
Schatten kein extra Bild w?re sondern irgendwie dynamisch in die Karten
rein-gerendert werden w?rde... Die Animationen sind bei mir jetzt
n?mlich deutlich langsamer.
Au?erdem kann ich mir die Grafikfehler rechts unten nicht erkl?ren (die
senkrechten grauen Linien). M?ssen durch die Animation entstanden sein.

Benni
-------------- next part --------------
A non-text attachment was scrubbed...
Name: screen12.png
Type: image/png
Size: 289782 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/f6733f3a/attachment.png>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Dies ist ein digital signierter Nachrichtenteil
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/f6733f3a/attachment.pgp>

From domseichter at web.de  Thu Feb 10 10:52:52 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 10:52:52 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Es kann jetzt ein Hintergrundbild eingestellt
In-Reply-To: <200502091807.j19I7EUt006677@sheep.berlios.de>
References: <200502091807.j19I7EUt006677@sheep.berlios.de>
Message-ID: <200502101052.52909.domseichter@web.de>

Great! 

ImgBack2 kannst Du Dir aber glaub ich sparen.
Statt:
ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
Sollte:
ImgBack=ImgBack.smoothScale( canvas()->width(), canvas()->height() );

Auch gehen. Ausserdem reicht es glaub ich wenn ImgBack eine Lokale Variable 
ist anstatt ein Classmember -> spart RAM :).

Jetzt muss irgendwer einen Tisch im B?rgerbr?u von oben Fotografieren, damit 
wir einen passenden Hintergrund haben :-D. Wer meldet sich freiwillig?

CU Dom

Am Wednesday, 9. February 2005 19:07 schrieb schafkopf-devel at berlios.de:
> Log Message:
> -----------
> Es kann jetzt ein Hintergrundbild eingestellt werden.
> Pfad muss unter "Schafkopf einrichten..."->"Anzeige" per Hand eingegeben
> werden. Danach ist leider noch ein Neustart notwendig. (Hilfe Dom!!)
> Beispiel: http://www.kruegeroliver.de/magic/holz.jpg (natuerlich erst lokal
> speichern ;-) )
>
> Modified Files:
> --------------
>     schafkopf/src:
>         gamecanvas.cpp
>         gamecanvas.h
>         preferencesdlg.cpp
>         preferencesdlg.h
>         settings.cpp
>         settings.h

-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From domseichter at web.de  Thu Feb 10 11:19:52 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 11:19:52 +0100
Subject: [Schafkopf-devel] Screenshot
In-Reply-To: <1108001892.16068.17.camel@amd2000xp>
References: <1108001892.16068.17.camel@amd2000xp>
Message-ID: <200502101119.52436.domseichter@web.de>

Am Thursday, 10. February 2005 03:18 schrieb Benjamin L?we:
> Hier noch mal ein screenshot damit sich sich auch der lernende Teil der
> Bev?lkerung ein Bild davon machen kann. :-)
>
> Hab mir grad gedacht, dass es vielleicht sinnvoller ist, wenn der
> Schatten kein extra Bild w?re sondern irgendwie dynamisch in die Karten
> rein-gerendert werden w?rde... Die Animationen sind bei mir jetzt
> n?mlich deutlich langsamer.
> Au?erdem kann ich mir die Grafikfehler rechts unten nicht erkl?ren (die
> senkrechten grauen Linien). M?ssen durch die Animation entstanden sein.
Grafikfehler: Hast Du setSize() richtig angepasst? Du musst da noch die 
zus?tzliche H?he und Breite des Schattes addieren. Dann sollten die Grauen 
Linien verschwinden. QCanvas zeichnet n?mlich nur den durch setSize gegebenen 
Bereich neu.

Dynamisches Render: H?tte vor allem den Vorteil, dass es auf jedes Karten deck 
passt und  man keine Extra Alpha Karten braucht - daher leichter f?r den User 
ist. Kannst ja mal mit QPainter spielen :).

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From domseichter at web.de  Thu Feb 10 12:26:39 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 12:26:39 +0100
Subject: [Schafkopf-devel] [RFC][PATCH] Threading
Message-ID: <200502101226.40431.domseichter@web.de>

Hey Hey,

Der Angeh?ngt Patch l?sst Game in einem eigenem Thread laufen. Mit dem Patch 
(gegen HEAD) ist Schafkopf schon spielbar, einige Sachen funktionieren jedoch 
noch nicht. Daher hab ich das auch noch nicht ins CVS gestellt. Auserdem 
h?tte ich gerne Feedback, ob das ?berhaupt so passt was ich mache, da dass 
das erste gro?e Ding ist das ich mit Threads mache.

Am Ende sollte die Klasse GameCanvas kein Game Objekt mehr brauchen, da muss 
ich noch ein paar Sachen machen. Game braucht mittlerweile immerhin schon 
keine GameCanvas Objekt mehr. Zur Komunikation verwende ich im Moment QEvents 
da ich die unter Qt leicht mit postEvent von Thread zu Thread schicken kann. 
Das sollte sich aber sp?ter leicht auf Sockets umstellen lassen, aber das 
?berlasse ich den Leuten die den Netzwerk Code machen wollen.

Zur Komunikation wird im Moment die folgende Struktur verwendet:

typedef enum EAction { NoAction, GameStarted, GameEnded, PlayerDoubled, 
                       CardPlayed, PlayerMadeStich, PlayerResults, 
GameInfoSetup,
                       RedrawPlayers, InfoMessage, QuestionYesNo, 
                       HumanPlayerGetCard, ForbiddenCard, SelectGame,
                       ForcedSelectGame };

typedef struct t_EventData {
    EAction type;
    
    unsigned int playerid;
    void* returncode;
    int cardid;
    
    QString playername;
    QString data;
    QSemaphore* wait;
};

data verwende ich im Moment um Sachen wie "Do you want to play?" oder so zu 
fragen. Das sollte nat?rlich auch ?ber eine MessageTable geregelt werden, 
dann muss man da auch nur einen Enum Schicken. Auch sonst kann man das sicher 
noch vereinfachen. Das ich die Semaphore ?ber die Struktur schicke ist im 
Moment auch reine Bequemlichkeit. Kann eigentlich auch ?ber den Konstruktur 
des Threads gemacht werden.

Die Ankommenden Events werden in schafkopf.cpp abgefangen und von dort aus 
werden die Betreffenden Funktionen aufgerufen.

So: Bitte feedback! Kann man das so machen? Wollen wir das so machen? 

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************
-------------- next part --------------
A non-text attachment was scrubbed...
Name: schafkopf_thread.diff.bz2
Type: application/x-bzip2
Size: 9508 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/f2070873/attachment.bin>

From moesenle at in.tum.de  Thu Feb 10 13:11:09 2005
From: moesenle at in.tum.de (=?ISO-8859-1?Q?Lorenz_M=F6senlechner?=)
Date: Thu, 10 Feb 2005 13:11:09 +0100
Subject: [Schafkopf-devel] [RFC][PATCH] Threading
In-Reply-To: <200502101226.40431.domseichter@web.de>
References: <200502101226.40431.domseichter@web.de>
Message-ID: <420B4F5D.1030501@in.tum.de>

Sars die Liste :)
Hab mal ein wenig in dem Patch rumgelesen. Sind einige ganz gute ans?tze 
drin.
Was mich da interessieren w?rde: f?r was benutzt du denn den semaphor? 
Um zu warten, ob der Event schon bearbeitet wurde? Initialisier den doch 
einfach mit null und versuch im postEvent nen dekrement. Und im 
customEvent machst du einfach nen inkrement, wenn du fertig bist. Dann 
sparst du dir das doppelte inkrement und dekrement (ich versteh eh nicht 
wieso :) )
Was ich noch nicht optimal finde, ist, dass die spieler im Thread vom 
Spiel laufen. Die spieler und das spiel sollten auch entweder ?ber die 
events oder sp?ter evtl. ?ber socks kommunizieren. Dann sparst du dir 
auch die synchronisation von HumanPlayer und GameCanvas weil der 
HumanPlayer im Hauptprogramm-Tread laufen kann und nur das spiel und die 
computerspieler in nem extra thread. Ich werd das game und die 
player-schnittstelle sowieso f?r meine ki-experimente fr?her oder sp?ter 
ohne qt brauchen. Aber so wies im mom l?uft is es nicht allzu schwierig 
umzustellen.
Was ich sehr sehr gut finde, ist, dass wir kein enter- und exitloop haben.

Gruss Lenz


From domseichter at web.de  Thu Feb 10 13:47:09 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 13:47:09 +0100
Subject: [Schafkopf-devel] [RFC][PATCH] Threading
In-Reply-To: <420B4F5D.1030501@in.tum.de>
References: <200502101226.40431.domseichter@web.de> <420B4F5D.1030501@in.tum.de>
Message-ID: <200502101347.10577.domseichter@web.de>

Hallo Ihr,

Am Thursday, 10. February 2005 13:11 schrieb Lorenz M?senlechner:
> Sars die Liste :)
> Hab mal ein wenig in dem Patch rumgelesen. Sind einige ganz gute ans?tze
> drin.
Thanks a lot!

> Was mich da interessieren w?rde: f?r was benutzt du denn den semaphor?
> Um zu warten, ob der Event schon bearbeitet wurde? Initialisier den doch
> einfach mit null und versuch im postEvent nen dekrement. Und im
> customEvent machst du einfach nen inkrement, wenn du fertig bist. Dann
> sparst du dir das doppelte inkrement und dekrement (ich versteh eh nicht
> wieso :) )
Der Gamethread muss ja bei manchen Events auf den Returncode warten. Daher 
benutze ich die Semaphore zum Blocken. Mit dem ersten inkrement belege ich 
sie und beim 2. inkrement blocked der Game Thread. 
Das mit dem dekrement Funzt bei Qt Semaphoren nicht. Evtl. sollten wir dann 
POSIX semaphoren verwenden wenn es da geht. Obwohl ich das jetzt so lassen 
w?rde, da wir es sowieso anders l?sen m?ssen sobald wir aus Sockets 
umstellen.

> Was ich noch nicht optimal finde, ist, dass die spieler im Thread vom
> Spiel laufen. Die spieler und das spiel sollten auch entweder ?ber die
> events oder sp?ter evtl. ?ber socks kommunizieren. Dann sparst du dir
> auch die synchronisation von HumanPlayer und GameCanvas weil der
> HumanPlayer im Hauptprogramm-Tread laufen kann und nur das spiel und die
> computerspieler in nem extra thread. Ich werd das game und die
> player-schnittstelle sowieso f?r meine ki-experimente fr?her oder sp?ter
> ohne qt brauchen. Aber so wies im mom l?uft is es nicht allzu schwierig
> umzustellen.
Auf ohne Qt umstellen sollte jetzt deutlich leichter sein. Im wesentlichen 
m?ssen denke ich bloss CardList und einige QStrings umgestellt werden.

Die Spieler in eigene Threads packen ist dann der n?chste Schritt, sobald Game 
und GameCanvas unabh?ngig von einander laufen.

> Was ich sehr sehr gut finde, ist, dass wir kein enter- und exitloop haben.
:-D

Was ich auch noch ?ndern muss ist die Settings Sache, so wie es jetzt ist kann 
das nicht gut gehen, da das Settings Object von 2 Threads gleichzeitig 
verwendet wird. 

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From benjamin.loewe at web.de  Thu Feb 10 14:30:42 2005
From: benjamin.loewe at web.de (Benjamin =?ISO-8859-1?Q?L=F6we?=)
Date: Thu, 10 Feb 2005 14:30:42 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Es kann jetzt ein
	Hintergrundbild eingestellt
In-Reply-To: <200502101052.52909.domseichter@web.de>
References: <200502091807.j19I7EUt006677@sheep.berlios.de>
	 <200502101052.52909.domseichter@web.de>
Message-ID: <1108042242.12304.7.camel@amd2000xp>

Am Donnerstag, den 10.02.2005, 10:52 +0100 schrieb Dominik Seichter:
> Great! 
Danke!

> ImgBack2 kannst Du Dir aber glaub ich sparen.
> Statt:
> ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
> Sollte:
> ImgBack=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
> 
> Auch gehen. Ausserdem reicht es glaub ich wenn ImgBack eine Lokale Variable 
> ist anstatt ein Classmember -> spart RAM :).
Probiers doch mal aus :-) Nach einmal verkleinern und wieder vergr??ern
hast du ein ziemlich unscharfes Bild.
Ok ImgBack2 kann ich lokal benutzen aber ImgBack1 wird ja im Konstruktor
verwendet.
> Jetzt muss irgendwer einen Tisch im B?rgerbr?u von oben Fotografieren, damit 
> wir einen passenden Hintergrund haben :-D. Wer meldet sich freiwillig?
Au?erdem noch im Baamhakke und im Schmuggler :-)
@Gitschei: Wo bleibt des Bild von unserem K?chentisch :-)

Benni
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 189 bytes
Desc: Dies ist ein digital signierter Nachrichtenteil
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/7e2fde11/attachment.pgp>

From schafkopf-devel at berlios.de  Thu Feb 10 14:37:51 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 14:37:51 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Ueberprfuefung einbaut ob Hintergrundbild und
Message-ID: <200502101337.j1ADbpNp004861@sheep.berlios.de>

Log Message:
-----------
Ueberprfuefung einbaut ob Hintergrundbild und Alphakarten geladen werden konnten.

Modified Files:
--------------
    schafkopf/src:
        canvascard.cpp
        canvascard.h
        gamecanvas.cpp
        gamecanvas.h

-------------- next part --------------
Index: gamecanvas.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.h,v
retrieving revision 1.22
retrieving revision 1.23
diff -Lsrc/gamecanvas.h -Lsrc/gamecanvas.h -u -r1.22 -r1.23
--- src/gamecanvas.h
+++ src/gamecanvas.h
@@ -104,7 +104,8 @@
                 
         Game* m_game;
 
-        QImage ImgBack, ImgBack2;
+        QImage ImgBack;
+        bool loadOK;
 };
 
 #endif
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.13 -r1.14
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -37,8 +37,8 @@
     m_forbidden = false;
     show();
     timer = new QTimer( this );
-    Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
-    Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
+    loadOK1 = Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
+    loadOK2 = Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
 }
 
 CanvasCard::CanvasCard(Card* card,QCanvas*c)
@@ -76,12 +76,15 @@
         if( m_forbidden )
             pix = KPixmapEffect::fade( pix, 0.5, Qt::gray );
         
-        setSize( pix.width(), pix.height() );
+        setSize( pix.width()+3, pix.height()+3 );
         bitBlt( p.device(), point.x(), point.y(), &pix );
-        if( m_rotation==0 || m_rotation==180)
+        if(loadOK1 && loadOK2)
+        {
+	if( m_rotation==0 || m_rotation==180)
             bitBlt( p.device(), point.x(), point.y(), &Shadow );
         else
             bitBlt( p.device(), point.x(), point.y(), &Shadow2 );
+        }
     }
 }
 
Index: canvascard.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -Lsrc/canvascard.h -Lsrc/canvascard.h -u -r1.10 -r1.11
--- src/canvascard.h
+++ src/canvascard.h
@@ -21,7 +21,6 @@
 #define CANVASCARD_H
 
 #include <qcanvas.h>
-#include <qimage.h>
 
 #define CANVASCARD 1000
 
@@ -66,7 +65,8 @@
 	QTimer *timer;
         
         Card* m_card;
-        QImage Shadow, Shadow2;
+        QPixmap Shadow, Shadow2;
+	bool loadOK1, loadOK2;
 
 	private slots:
 		void disableForbidden();
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.38
retrieving revision 1.39
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.38 -r1.39
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -69,7 +69,7 @@
     
     canvas()->setBackgroundColor( Qt::darkGreen );
     
-    ImgBack.load( Settings::instance()->backgroundImage() );
+    loadOK = ImgBack.load( Settings::instance()->backgroundImage() );
     canvas()->setAdvancePeriod( 20 );
     update();
     
@@ -304,13 +304,17 @@
 
 void GameCanvas::resizeEvent( QResizeEvent * r )
 {
+    QImage ImgBack2;
     canvas()->resize( this->width() -2, this->height()-2 );
     QCanvasView::resizeEvent( r );
     
     positionObjects();
     
-    ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
-    canvas()->setBackgroundPixmap( ImgBack2 );
+    if(loadOK)
+    {
+         ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
+         canvas()->setBackgroundPixmap( ImgBack2 );
+    }
 }
 
 void GameCanvas::redrawPlayers()

From schafkopf-devel at berlios.de  Thu Feb 10 16:12:15 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 16:12:15 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Alpha-Karten fue Bavarian-Old hinzugefuegt.
Message-ID: <200502101512.j1AFCFcn014988@sheep.berlios.de>

Log Message:
-----------
Alpha-Karten fue Bavarian-Old hinzugefuegt.

Modified Files:
--------------
    schafkopf/carddecks/cards-bavarian-old:
        Makefile.am

Added Files:
-----------
    schafkopf/carddecks/cards-bavarian-old:
        alpha1.png
        alpha2.png

-------------- next part --------------
Index: Makefile.am
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/carddecks/cards-bavarian-old/Makefile.am,v
retrieving revision 1.1
retrieving revision 1.2
diff -Lcarddecks/cards-bavarian-old/Makefile.am -Lcarddecks/cards-bavarian-old/Makefile.am -u -r1.1 -r1.2
--- carddecks/cards-bavarian-old/Makefile.am
+++ carddecks/cards-bavarian-old/Makefile.am
@@ -1,5 +1,10 @@
-
-datafiles_DATA = 10.png 11.png 12.png 13.png 14.png 15.png  16.png  17.png 18.png 19.png 1.png 20.png 21.png 22.png 23.png 24.png 25.png 26.png 27.png 28.png 29.png 2.png 30.png 31.png 32.png 33.png 34.png 35.png 36.png 37.png 38.png 39.png 3.png 40.png 41.png 42.png 43.png 44.png 45.png 46.png 47.png 48.png 49.png 4.png 50.png 51.png 52.png 5.png 6.png 7.png 8.png 9.png COPYRIGHT index.desktop
-
-datafilesdir = $(kde_datadir)/carddecks/cards-bavarian-old/
-
+
+datafiles_DATA = 10.png 11.png 12.png 13.png 14.png 15.png 16.png 17.png 18.png \
+	19.png 1.png 20.png 21.png 22.png 23.png 24.png 25.png 26.png 27.png 28.png \
+	29.png 2.png 30.png 31.png 32.png 33.png 34.png 35.png 36.png 37.png 38.png \
+	39.png 3.png 40.png 41.png 42.png 43.png 44.png 45.png 46.png 47.png 48.png \
+	49.png 4.png 50.png 51.png 52.png 5.png 6.png 7.png 8.png 9.png COPYRIGHT \
+	index.desktop alpha1.png alpha2.png
+
+datafilesdir = $(kde_datadir)/carddecks/cards-bavarian-old/
+

From domseichter at web.de  Thu Feb 10 17:14:17 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 17:14:17 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Es kann jetzt ein Hintergrundbild eingestellt
In-Reply-To: <1108042242.12304.7.camel@amd2000xp>
References: <200502091807.j19I7EUt006677@sheep.berlios.de> <200502101052.52909.domseichter@web.de> <1108042242.12304.7.camel@amd2000xp>
Message-ID: <200502101714.17171.domseichter@web.de>

Am Thursday, 10. February 2005 14:30 schrieb Benjamin L?we:
> Am Donnerstag, den 10.02.2005, 10:52 +0100 schrieb Dominik Seichter:
> > Great!
>
> Danke!
>
> > ImgBack2 kannst Du Dir aber glaub ich sparen.
> > Statt:
> > ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
> > Sollte:
> > ImgBack=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
> >
> > Auch gehen. Ausserdem reicht es glaub ich wenn ImgBack eine Lokale
> > Variable ist anstatt ein Classmember -> spart RAM :).
>
> Probiers doch mal aus :-) Nach einmal verkleinern und wieder vergr??ern
> hast du ein ziemlich unscharfes Bild.
> Ok ImgBack2 kann ich lokal benutzen aber ImgBack1 wird ja im Konstruktor
> verwendet.
Stimmt. Hab gedacht, dass wird auch gleich im Konstruktor gesetzt. Das mit dem 
resizeEvent hab ich ?berlesen :-(.

Kannst Du im PreferencesDlg statt KLineEdit KURLRequester zum Pfad ausw?hlen 
benutzen? Den Pfad vom Hand eintippen ist was f?rn Lenz aber nicht f?r 
normale User :). 

> > Jetzt muss irgendwer einen Tisch im B?rgerbr?u von oben Fotografieren,
> > damit wir einen passenden Hintergrund haben :-D. Wer meldet sich
> > freiwillig?
>
> Au?erdem noch im Baamhakke und im Schmuggler :-)
> @Gitschei: Wo bleibt des Bild von unserem K?chentisch :-)
>
> Benni

-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From schafkopf-devel at berlios.de  Thu Feb 10 17:53:38 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 17:53:38 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Auswahldialog fuer hintergrundbild
Message-ID: <200502101653.j1AGrcw0020664@sheep.berlios.de>

Log Message:
-----------
Auswahldialog fuer hintergrundbild

Modified Files:
--------------
    schafkopf/src:
        preferencesdlg.cpp
        preferencesdlg.h

-------------- next part --------------
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.15
retrieving revision 1.16
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.15 -r1.16
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -24,6 +24,7 @@
 #include <klocale.h>
 #include <knuminput.h>
 #include <klineedit.h>
+#include <kurlrequester.h>
 
 #include <qframe.h>
 #include <qlayout.h>
@@ -92,7 +93,7 @@
     s->setDoubleNextGame( m_checkDoubleNextGame->isChecked() );
     
     s->setRearrangeCards( m_checkRearrangeCards->isChecked() );
-    s->setBackgroundImage( m_linePathBackground->text() );
+    s->setBackgroundImage( m_linePathBackground->url() );
     
     // allowed games
     allowed.wenz = m_games_wenz->isChecked();
@@ -271,7 +272,7 @@
     
     QVButtonGroup* group2 = new QVButtonGroup( i18n("Game Canvas:"), box, "group2" );
     QLabel* label3 = new QLabel( i18n("Background image:"), group2, "label3" );
-    m_linePathBackground = new KLineEdit( Settings::instance()->backgroundImage(), group2, "m_linePathBackground" );
+    m_linePathBackground = new KURLRequester( Settings::instance()->backgroundImage(), group2, "m_linePathBackground" );
         
     QVButtonGroup* group = new QVButtonGroup( i18n("Card Arrangement:"), box, "group" );
     m_checkRearrangeCards = new QCheckBox ( i18n("Rearrange cards after each trick."), group );
Index: preferencesdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -Lsrc/preferencesdlg.h -Lsrc/preferencesdlg.h -u -r1.12 -r1.13
--- src/preferencesdlg.h
+++ src/preferencesdlg.h
@@ -29,6 +29,7 @@
 class QLabel;
 class QSpinBox;
 class QCheckBox;
+class KURLRequester;
 
 /**
 Preferences dialog for schafkopf
@@ -78,7 +79,8 @@
         KLineEdit* m_p2_name;
         KLineEdit* m_p3_name;
         KLineEdit* m_p4_name;
-        KLineEdit* m_linePathBackground;
+
+        KURLRequester* m_linePathBackground;
         
         KDoubleNumInput* m_money_solo;
         KDoubleNumInput* m_money_call;

From kernch at in.tum.de  Thu Feb 10 17:40:30 2005
From: kernch at in.tum.de (Kern Christian)
Date: Thu, 10 Feb 2005 17:40:30 +0100
Subject: [Schafkopf-devel] Dietersheim
In-Reply-To: <200502101714.17171.domseichter@web.de>
References: <200502091807.j19I7EUt006677@sheep.berlios.de> <1108042242.12304.7.camel@amd2000xp> <200502101714.17171.domseichter@web.de>
Message-ID: <200502101740.42428.kernch@in.tum.de>

@Benni
...der legendere Dietersheimer Schafkopftisch :)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tisch1.jpg
Type: image/jpeg
Size: 68506 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/6626c9ce/attachment.jpg>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tisch2.jpg
Type: image/jpeg
Size: 66306 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/6626c9ce/attachment-0001.jpg>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050210/6626c9ce/attachment.pgp>

From schafkopf-devel at berlios.de  Thu Feb 10 20:02:42 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 20:02:42 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf kein neustart nach wechsel des
Message-ID: <200502101902.j1AJ2gJx007225@sheep.berlios.de>

Log Message:
-----------
kein neustart nach wechsel des hintergrundbildes mehr noetig (danke Dom!)

Modified Files:
--------------
    schafkopf/src:
        gamecanvas.cpp
        gamecanvas.h
        schafkopf.cpp

-------------- next part --------------
Index: schafkopf.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopf.cpp,v
retrieving revision 1.33
retrieving revision 1.34
diff -Lsrc/schafkopf.cpp -Lsrc/schafkopf.cpp -u -r1.33 -r1.34
--- src/schafkopf.cpp
+++ src/schafkopf.cpp
@@ -297,7 +297,7 @@
     PreferencesDlg prefs( this, "prefs");
     if( prefs.exec() == QDialog::Accepted )
     {
-    
+    m_canvasview->updateBackground();
     }
 }
 
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.39
retrieving revision 1.40
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.39 -r1.40
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -304,17 +304,28 @@
 
 void GameCanvas::resizeEvent( QResizeEvent * r )
 {
-    QImage ImgBack2;
     canvas()->resize( this->width() -2, this->height()-2 );
     QCanvasView::resizeEvent( r );
     
     positionObjects();
-    
+    resizeBackground();
+}
+
+void GameCanvas::resizeBackground()
+{
+    QImage ImgBack2;
     if(loadOK)
     {
          ImgBack2=ImgBack.smoothScale( canvas()->width(), canvas()->height() );
          canvas()->setBackgroundPixmap( ImgBack2 );
     }
+
+}
+
+void GameCanvas::updateBackground()
+{
+    loadOK = ImgBack.load( Settings::instance()->backgroundImage() );
+    resizeBackground();
 }
 
 void GameCanvas::redrawPlayers()
Index: gamecanvas.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.h,v
retrieving revision 1.23
retrieving revision 1.24
diff -Lsrc/gamecanvas.h -Lsrc/gamecanvas.h -u -r1.23 -r1.24
--- src/gamecanvas.h
+++ src/gamecanvas.h
@@ -59,6 +59,7 @@
         /** display an information message to the user
           */
         void information( const QString & message );
+        void updateBackground();
           
     public slots:
         void redrawPlayers();
@@ -80,7 +81,8 @@
         
     protected:
         void resizeEvent( QResizeEvent *r );
-        
+        void resizeBackground();
+
         void contentsMousePressEvent(QMouseEvent*);
         void contentsMouseReleaseEvent(QMouseEvent*);
                 

From schafkopf-devel at berlios.de  Thu Feb 10 21:49:43 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Thu, 10 Feb 2005 21:49:43 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf neuer button: hintergrundbild loeschen
Message-ID: <200502102049.j1AKnhJY012830@sheep.berlios.de>

Log Message:
-----------
neuer button: hintergrundbild loeschen

Modified Files:
--------------
    schafkopf/src:
        gamecanvas.cpp
        preferencesdlg.cpp
        preferencesdlg.h

-------------- next part --------------
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.16
retrieving revision 1.17
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.16 -r1.17
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -273,6 +273,7 @@
     QVButtonGroup* group2 = new QVButtonGroup( i18n("Game Canvas:"), box, "group2" );
     QLabel* label3 = new QLabel( i18n("Background image:"), group2, "label3" );
     m_linePathBackground = new KURLRequester( Settings::instance()->backgroundImage(), group2, "m_linePathBackground" );
+    m_pushURLClear = new QPushButton( i18n("clear background image"), group2, "m_pushURLClear" );
         
     QVButtonGroup* group = new QVButtonGroup( i18n("Card Arrangement:"), box, "group" );
     m_checkRearrangeCards = new QCheckBox ( i18n("Rearrange cards after each trick."), group );
@@ -282,6 +283,8 @@
     layout->addWidget( group );
     layout->addItem( spacer );
     
+    connect( m_pushURLClear, SIGNAL( clicked() ), m_linePathBackground, SLOT( clear() ) );
+
     // load data from configuration
     m_checkRearrangeCards->setChecked( Settings::instance()->rearrangeCards() );
 }
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.40
retrieving revision 1.41
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.40 -r1.41
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -180,37 +180,37 @@
     int h = canvas()->height();//-DIST;
     int cardw = Card::backgroundPixmap()->width();
     int cardh = Card::backgroundPixmap()->height();
-    int stichcanvasw = canvas()->width() - (4*DIST) - (2*cardh);
-    int stichcanvash = canvas()->height() - (4*DIST) - (2*cardh);
+    int stichcanvasw = canvas()->width() - (2*DIST) - (2*cardh) - 50;
+    int stichcanvash = canvas()->height() - (2*DIST) - (2*cardh) - 50;
     int cx = w/2;
     int cy = h/2;
     
     switch( player ) 
     {
         case 0:
-            if(stichcanvash>(2*cardh))
-	    	p = QPoint(cx-(cardw/2), cy );
+            if(stichcanvash>(2*cardh-20))
+	    	p = QPoint(cx-(cardw/2)-5, cy-10 );
 	    else
-	    	p = QPoint(cx-(cardw/2), cy+(stichcanvash/2)-cardh);
+	    	p = QPoint(cx-(cardw/2)-5, cy+(stichcanvash/2)-cardh);
 	    break;
         case 1:
-	    if(stichcanvasw>(2*cardh))
-            	p = QPoint(cx-cardh, cy-(cardw/2));
+	    if(stichcanvasw>(2*cardh-20))
+            	p = QPoint(cx-cardh+10, cy-(cardw/2)-5);
 	    else
-	    	p = QPoint(cx-(stichcanvasw/2), cy-(cardw/2));
+	    	p = QPoint(cx-(stichcanvasw/2), cy-(cardw/2)-5);
 	    break;
         case 2:
-            if(stichcanvash>(2*cardh))
-            	p = QPoint(cx-(cardw/2), cy-cardh );
+            if(stichcanvash>(2*cardh-20))
+            	p = QPoint(cx-(cardw/2)+5, cy-cardh+10 );
 	    else
-	    	p = QPoint(cx-(cardw/2), cy-(stichcanvash/2));
+	    	p = QPoint(cx-(cardw/2)+5, cy-(stichcanvash/2));
 	    break;
         case 3:
         default:
-	    if(stichcanvasw>(2*cardh))
-            	p = QPoint(cx, cy-(cardw/2));
+	    if(stichcanvasw>(2*cardh-20))
+            	p = QPoint(cx-10, cy-(cardw/2)+5);
 	    else
-	    	p = QPoint(cx+(stichcanvasw/2)-cardh, cy-(cardw/2));
+	    	p = QPoint(cx+(stichcanvasw/2)-cardh, cy-(cardw/2)+5);
 	    break;
     };
         
@@ -326,6 +326,8 @@
 {
     loadOK = ImgBack.load( Settings::instance()->backgroundImage() );
     resizeBackground();
+    if(!loadOK)
+         canvas()->setBackgroundPixmap( NULL );
 }
 
 void GameCanvas::redrawPlayers()
Index: preferencesdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/preferencesdlg.h -Lsrc/preferencesdlg.h -u -r1.13 -r1.14
--- src/preferencesdlg.h
+++ src/preferencesdlg.h
@@ -29,6 +29,7 @@
 class QLabel;
 class QSpinBox;
 class QCheckBox;
+class QPushButton;
 class KURLRequester;
 
 /**
@@ -81,6 +82,8 @@
         KLineEdit* m_p4_name;
 
         KURLRequester* m_linePathBackground;
+
+        QPushButton* m_pushURLClear;
         
         KDoubleNumInput* m_money_solo;
         KDoubleNumInput* m_money_call;

From domseichter at web.de  Thu Feb 10 21:59:44 2005
From: domseichter at web.de (Dominik Seichter)
Date: Thu, 10 Feb 2005 21:59:44 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf neuer button: hintergrundbild loeschen
In-Reply-To: <200502102049.j1AKnhJY012830@sheep.berlios.de>
References: <200502102049.j1AKnhJY012830@sheep.berlios.de>
Message-ID: <200502102159.44111.domseichter@web.de>

Um das ganze noch sch?ner zu machen kannst Du den Button immer aus disabled 
stellen wenn kein Hintergrundbild gesetzt ist, also der URLRequester leer 
ist. Dazuz kannst Du die denke ich die enableControls() funktion erweitern :)

CU Dom 

Am Thursday, 10. February 2005 21:49 schrieb schafkopf-devel at berlios.de:
> Log Message:
> -----------
> neuer button: hintergrundbild loeschen
>
> Modified Files:
> --------------
>     schafkopf/src:
>         gamecanvas.cpp
>         preferencesdlg.cpp
>         preferencesdlg.h

-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From schafkopf-devel at berlios.de  Fri Feb 11 03:18:14 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Fri, 11 Feb 2005 03:18:14 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf doms vorschlag + uebersetzung
Message-ID: <200502110218.j1B2IESZ021673@sheep.berlios.de>

Log Message:
-----------
doms vorschlag + uebersetzung

Modified Files:
--------------
    schafkopf/po:
        de.po
    schafkopf/src:
        preferencesdlg.cpp
        preferencesdlg.h

-------------- next part --------------
Index: de.po
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/po/de.po,v
retrieving revision 1.19
retrieving revision 1.20
diff -Lpo/de.po -Lpo/de.po -u -r1.19 -r1.20
--- po/de.po
+++ po/de.po
@@ -326,6 +326,9 @@
 msgid "Background image:"
 msgstr "Hintergrundbild:"
 
+msgid "clear background image"
+msgstr "Hintergrundbild entfernen"
+
 msgid "Games"
 msgstr "Spiele"
 
Index: preferencesdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -Lsrc/preferencesdlg.h -Lsrc/preferencesdlg.h -u -r1.14 -r1.15
--- src/preferencesdlg.h
+++ src/preferencesdlg.h
@@ -49,6 +49,7 @@
     
     private slots:
         void enableControls();
+        void disableClearButton(const QString & url);
         
     private:
         void addPagePlayer();
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.17
retrieving revision 1.18
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.17 -r1.18
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -284,6 +284,7 @@
     layout->addItem( spacer );
     
     connect( m_pushURLClear, SIGNAL( clicked() ), m_linePathBackground, SLOT( clear() ) );
+    connect( m_linePathBackground, SIGNAL( textChanged(const QString &) ), this, SLOT( disableClearButton(const QString &) ) );
 
     // load data from configuration
     m_checkRearrangeCards->setChecked( Settings::instance()->rearrangeCards() );
@@ -345,6 +346,14 @@
     
     m_games_farbwenz->setEnabled( m_games_wenz->isChecked() );
     m_games_farbgeier->setEnabled( m_games_geier->isChecked() );
+}
+
+void PreferencesDlg::disableClearButton(const QString & url)
+{
+    if(url=="")
+        m_pushURLClear->setEnabled( false );
+    else
+        m_pushURLClear->setEnabled( true );
 }
 
 #include "preferencesdlg.moc"

From domseichter at web.de  Sat Feb 12 16:26:34 2005
From: domseichter at web.de (Dominik Seichter)
Date: Sat, 12 Feb 2005 16:26:34 +0100
Subject: [Schafkopf-devel] [PATCH] Threading Patch
Message-ID: <200502121626.34419.domseichter@web.de>

Hi all,

Die aktuelle Version meines Threading Patches. 
Hab weiter im Code rumgew?tet:
Die Core-Game-Klassen (Game, Player, Card) sind keine QObjects mehr.
GameCanvas und CanvasPlayer kommen ohne Game und Player Objekte aus.
Und es gibt bei mir keine Deadlocks und "Verklemmungen" (<- neues wort, heute 
erst gelernt :) ) mehr.

Ich denke das ist mittlerweile Reif f?rs CVS. Ihr habt bis morgen Abend zeit 
mir zu wieder sprechen, sonst wirds commited.

Wer den Patch vorher probieren will holt sich CVS HEAD und dann:
cd schafkopf
cd src
patch < schafkopf_thread_2.diff

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************
-------------- next part --------------
A non-text attachment was scrubbed...
Name: schafkopf_thread_2.diff.bz2
Type: application/x-bzip2
Size: 15135 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050212/b73e9b8d/attachment.bin>

From schafkopf-devel at berlios.de  Sun Feb 13 14:19:44 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sun, 13 Feb 2005 14:19:44 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Keiner hat sich beschwert, also stell ich den
Message-ID: <200502131319.j1DDJiJA014620@sheep.berlios.de>

Log Message:
-----------
Keiner hat sich beschwert, also stell ich den Patch ins CVS.
Seit dem letzten Patch nehmen ich jetzt POSIX Semaphoren her 
(QSemaphore stinkt wirklich). L?uft jetzt _denke_ ich ganz gut
aber testet selbst.

Modified Files:
--------------
    schafkopf/src:
        canvascard.cpp
        canvascard.h
        canvasplayer.cpp
        canvasplayer.h
        card.cpp
        card.h
        cardlist.cpp
        cardlist.h
        computerplayer.cpp
        computerplayer.h
        game.cpp
        game.h
        gamecanvas.cpp
        gamecanvas.h
        gameinfo.h
        humanplayer.cpp
        humanplayer.h
        player.cpp
        player.h
        pointresults.cpp
        schafkopf.cpp
        schafkopf.h
        schafkopfdef.h
        selectgametypebox.cpp
        settings.cpp
        settings.h
        stichdlg.cpp
        stichdlg.h

-------------- next part --------------
Index: schafkopfdef.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopfdef.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -Lsrc/schafkopfdef.h -Lsrc/schafkopfdef.h -u -r1.6 -r1.7
--- src/schafkopfdef.h
+++ src/schafkopfdef.h
@@ -26,6 +26,39 @@
 #define TURNS     8
 #define CARD_CNT  32
 
+/** Identify events from schafkopf in the Qt event loop
+  * using this ID.
+  */
+#define SCHAFKOPF_EVENT 1984
+
+#include <qstring.h>
+
+class Card;
+class QSemaphore;
+class QStringList;
+
+enum { YES, NO };
+    
+typedef enum EAction { NoAction, GameStarted, GameEnded, PlayerDoubled, 
+                       PlayerHasDoubled, PlayerIsLast, PlayerNameChanged, PlayerGotCards,
+                       CardPlayed, PlayerMadeStich, PlayerResults, GameInfoSetup,
+                       RedrawPlayers, InfoMessage, QuestionYesNo, 
+                       HumanPlayerGetCard, ForbiddenCard, SelectGame,
+                       ForcedSelectGame };
+
+typedef struct t_EventData {
+    EAction type;
+    
+    unsigned int playerid;
+    void* returncode;
+    int* cardids;
+
+    bool wait;
+    bool quitgame;
+    
+    QStringList* playernames;
+    QString data;
+};
 
 /** Uncomment this line to make all cards
   * user visible, this is useful for debugging
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.41
retrieving revision 1.42
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.41 -r1.42
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -39,10 +39,9 @@
     for(;i<PLAYERS;i++)
     {
         m_stich[i]=new CanvasCard( c );
-        m_players[i]=new CanvasPlayer( c );
+        m_players[i]=new CanvasPlayer( i, c );
     }
     
-    m_game = NULL;
     m_item = NULL;
         
     QFont f( "Helvetica", 24 );
@@ -75,7 +74,6 @@
     
     connect( Settings::instance(), SIGNAL(cardChanged()), this, SLOT(redrawPlayers()));
     connect( Settings::instance(), SIGNAL(cardChanged()), this, SLOT(positionObjects()));
-    connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(cardClicked(QCanvasItem*)));
     connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(yesNoClicked(QCanvasItem*)));
 }    
 
@@ -83,29 +81,19 @@
 {
     for( unsigned int i = 0; i < PLAYERS; i++ )
     {
+        if( m_stich[i]->card() )
+            delete m_stich[i]->card();
+            
         delete m_stich[i];
         delete m_players[i];
     }
 }
 
-void GameCanvas::setGame( Game* game )
-{
-    connect( game, SIGNAL(playerPlayedCard(unsigned int,Card*)), this,SLOT(slotPlayerPlayedCard(unsigned int,Card*)));       
-        
-    connect( game, SIGNAL(playerMadeStich(unsigned int)), this,SLOT(slotPlayerMadeStich(unsigned int)));
-    
-    connect( game, SIGNAL(gameStarted()), this, SLOT(redrawPlayers()));
-    connect( game, SIGNAL(gameEnded()), this, SLOT(redrawPlayers()));
-    
-    m_game = game;
-    createObjects();
-}
-
-void GameCanvas::cardForbidden(Card* card)
+void GameCanvas::cardForbidden( int cardid )
 {
     for(unsigned int z=0;z<PLAYERS;z++)
 	{
-        CanvasCard* c = m_players[z]->hasCard( card );
+        CanvasCard* c = m_players[z]->hasCard( cardid );
         if( c )            
         {
             c->forbidden();
@@ -114,42 +102,10 @@
     }      
 }
 
-void GameCanvas::createObjects()
-{
-    if( !m_game )
-        return;
-    
-    unsigned int i = 0;
-    unsigned int h = 0;
-    unsigned int z = 0;
-	
-    /** We have to make sure that the human player == m_player[0] !
-      */
-    for( h=0;h<PLAYERS;h++ )    
-	{
-		if( m_game->findIndex( h )->rtti() == Player::HUMAN )
-        {
-			m_players[0]->setPlayer( 0, m_game->findIndex( h ) );
-            break;
-        }
-	}
-		
-    for( i=h+1;i<PLAYERS;i++ )
-        m_players[i-h]->setPlayer( i-h, m_game->findIndex( i ) );            
-	
-    for( z=0;z<h;z++)    
-        m_players[i-h+z]->setPlayer( i-h+z, m_game->findIndex( z ) );
-	
-    positionObjects();
-}
-
 void GameCanvas::positionObjects(bool redraw)
 {
-    if( !m_players[0] || !m_game || !m_stich )
-        return;
-
     for( unsigned int i = 0; i < PLAYERS; i++ )
-        m_players[i]->position( i );
+        m_players[i]->position();
     
     for( unsigned int i = 0; i < PLAYERS; i++ ) 
     {
@@ -235,6 +191,14 @@
     return r;
 }
 
+int GameCanvas::getCard()
+{
+    connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(cardClicked(QCanvasItem*)));
+    m_result = -1;
+    ENTER_LOOP();
+    
+    return m_result;
+}
 
 void GameCanvas::cardClicked( QCanvasItem* item )
 {
@@ -244,40 +208,41 @@
         
         for( unsigned int i = 0; i < PLAYERS; i++ ) 
         {
-            Player* player = m_players[i]->player();
-            if( m_players[i]->hasCard( card->card() ) && player->rtti() == Player::HUMAN )
+            if( m_players[i]->isHuman() && m_players[i]->hasCard( card->card()->id() ) )
             {
-                qDebug("card=%i color=%i", card->card()->card(), card->card()->color() );
-                emit playCard( card->card() );
+                m_result = card->card()->id();
+                disconnect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(cardClicked(QCanvasItem*)));
+                EXIT_LOOP();
             }
         }
     }
 }
 
-void GameCanvas::slotPlayerPlayedCard( unsigned int player, Card *c )
+void GameCanvas::slotPlayerPlayedCard( unsigned int player, int cardid )
 {
     QPoint point;
     unsigned int i=0;
     CanvasCard* card = 0;
-    if( !m_players[0] || !m_game || !m_stich )
-        return;    
            
     for(i=0;i<PLAYERS;i++)
-        if( m_players[i]->player()->id() == player )
+        if( m_players[i]->id() == player )
         {
-            card = m_players[i]->hasCard( c );
+            card = m_players[i]->hasCard( cardid );
             break;
         }
     
     if( card )
     {
         m_players[player]->cardPlayed( card->card() );
-	if(Settings::instance()->rearrangeCards())
-		m_players[player]->position( player );
+        if(Settings::instance()->rearrangeCards())
+            m_players[player]->position();
   
         CanvasCard* stich = m_stich[player];
-        stich->setCard( card->card() );
-	int r = getStichRotation(player);
+        if( stich->card() )
+            delete stich->card();
+        stich->setCard( new Card( card->card()->id() ) );
+        
+        int r = getStichRotation(player);
         stich->setRotation( r );
 
         // find out the correct z value of this card so that
@@ -336,7 +301,7 @@
 	
     for(i=0;i<PLAYERS;i++)
     {
-		m_players[i]->init(i);
+		m_players[i]->init();
         m_stich[i]->hide();
     }
 }
@@ -437,6 +402,68 @@
     canvas()->update();
         
     return;
+}
+
+void GameCanvas::playerHasDoubled( unsigned int id, bool value )
+{
+    int i;
+    for(i=0;i<PLAYERS;i++)
+        if( m_players[i]->id() == id )
+        {
+            m_players[i]->setHasDoubled( value );
+        }
+}
+
+void GameCanvas::playerIsLast( unsigned int id )
+{
+    int i;
+    for(i=0;i<PLAYERS;i++)
+        if( m_players[i]->id() == id )
+        {
+            m_players[i]->setLast( true );
+            // TODO: init is not a good name for this function...
+            m_players[i]->init();
+        }
+}
+
+void GameCanvas::setPlayerName( unsigned int id, const QString & name )
+{
+    int i;
+    for(i=0;i<PLAYERS;i++)
+        if( m_players[i]->id() == id )
+            m_players[i]->setName( name );
+
+}
+
+void GameCanvas::resetPlayers()
+{
+    int i;
+    
+    for(i=0;i<PLAYERS;i++)
+    {
+        m_players[i]->setHasDoubled( false );
+        m_players[i]->setLast( false );
+    }
+}
+
+void GameCanvas::resetPlayerCards()
+{
+    int i;
+    CardList list;
+        
+    for(i=0;i<PLAYERS;i++)    
+        m_players[i]->setCards( &list );
+}
+
+void GameCanvas::setPlayerCards( unsigned int id, int* cards )
+{
+    int i;
+    CardList list( cards );
+    list.setAutoDelete( false );
+    
+    for(i=0;i<PLAYERS;i++)
+        if( m_players[i]->id() == id )
+            m_players[i]->setCards( &list );
 }
 
 #include "gamecanvas.moc"
Index: card.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/card.cpp,v
retrieving revision 1.11
retrieving revision 1.12
diff -Lsrc/card.cpp -Lsrc/card.cpp -u -r1.11 -r1.12
--- src/card.cpp
+++ src/card.cpp
@@ -25,12 +25,39 @@
 
 #include <kapplication.h>
 #include <kcarddialog.h>
-#include <kconfig.h>
 
 QPixmap* Card::m_background = 0;
 
-Card::Card( const enum type t, const enum color c )
-    : QObject()
+Card::Card( const int id )
+{
+    enum EType t;
+    enum EColor c;
+    int i;
+    
+    // try to calculate the type and color from the id
+    for( i=Card::EICHEL; i <= Card::SCHELLEN; i++ )
+        if( (id - i - 1) % 4 == 0 )
+        {
+            t = (Card::EType)(id - i);
+            c = (Card::EColor)i;
+            
+            break;
+        }
+    
+    init( t, c );
+}
+
+Card::Card( const enum EType t, const enum EColor c )
+{
+    init( t, c );
+}
+
+Card::~Card()
+{
+    delete m_pixmap;
+}
+
+void Card::init( const enum EType t, const enum EColor c  )
 {
     m_pixmap = NULL;
     m_owner = NULL;
@@ -55,14 +82,6 @@
             m_points = 0;
             break;
     };
-    
-    connect( Settings::instance(), SIGNAL( cardChanged() ), this, SLOT( cardChanged() ));
-}
-
-
-Card::~Card()
-{
-    delete m_pixmap;
 }
 
 QPixmap* Card::pixmap()
@@ -92,11 +111,13 @@
 		return false;
 }
 
-void Card::cardChanged()
+void Card::cardDeckChanged()
 {
     delete m_pixmap;
     m_pixmap = NULL;
-    if( m_background ) {
+    
+    if( m_background ) 
+    {
         delete m_background;
         m_background = NULL;
     }
@@ -122,3 +143,7 @@
     return false;
 }
 
+int Card::id() const
+{
+    return m_card + m_color;
+}
Index: gamecanvas.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.h,v
retrieving revision 1.24
retrieving revision 1.25
diff -Lsrc/gamecanvas.h -Lsrc/gamecanvas.h -u -r1.24 -r1.25
--- src/gamecanvas.h
+++ src/gamecanvas.h
@@ -39,18 +39,18 @@
 {
     Q_OBJECT
     
-    enum { YES, NO };
-    
     public:
         GameCanvas(QCanvas* c,QWidget *parent = 0, const char *name = 0);
         ~GameCanvas();
         
-        void setGame( Game* game );
-   
+        /** the user has to click a card to play
+          */
+        int getCard();
+        
         /** the user played card, which
           * is forbidden to play!
           */
-        void cardForbidden( Card* card );
+        void cardForbidden( int cardid );
 
         /** ask the user a question and allow him to make a decision
           */
@@ -59,11 +59,30 @@
         /** display an information message to the user
           */
         void information( const QString & message );
+
+        /** set the canvas player with the @p id to have doubled in this game
+          */
+        void playerHasDoubled( unsigned int id, bool value );
+        
+        /** Reset all data of the canvas players to default values 
+          */
+        void resetPlayers();
+        /** remove all cards from the canvas player cardlists
+          * so that they are going to hide themselves
+          */
+        void resetPlayerCards();
+        
+        void playerIsLast( unsigned int id );
+        void setPlayerName( unsigned int id, const QString & name );
+        void setPlayerCards( unsigned int id, int* cards );
+        
         void updateBackground();
           
     public slots:
         void redrawPlayers();
-        
+        void slotPlayerPlayedCard( unsigned int player, int cardid );
+        void slotPlayerMadeStich(unsigned int);
+                
     signals:
         void clicked( QCanvasItem* item );
         void playCard( Card* card );
@@ -76,9 +95,6 @@
         void cardClicked( QCanvasItem* item );
         void yesNoClicked( QCanvasItem* item );
         
-        void slotPlayerPlayedCard( unsigned int player, Card *c );
-        void slotPlayerMadeStich(unsigned int);
-        
     protected:
         void resizeEvent( QResizeEvent *r );
         void resizeBackground();
@@ -87,9 +103,6 @@
         void contentsMouseReleaseEvent(QMouseEvent*);
                 
     private:
-        /** Create QCanvasItem's for all Cards 
-          */
-        void createObjects();
         int m_result;
         QPoint getStichPosition( int player );
         int getStichRotation( int player );
@@ -97,14 +110,13 @@
         
         CanvasPlayer* m_players[PLAYERS];
         CanvasCard* m_stich[PLAYERS];
+        
         QCanvasItem* m_item; // currently clicked item
 
         QCanvasText* m_message;
         QCanvasText* m_yes;
         QCanvasText* m_no;
         QCanvasText* m_ok;
-                
-        Game* m_game;
 
         QImage ImgBack;
         bool loadOK;
Index: card.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/card.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -Lsrc/card.h -Lsrc/card.h -u -r1.7 -r1.8
--- src/card.h
+++ src/card.h
@@ -20,9 +20,6 @@
 #ifndef CARD_H
 #define CARD_H
 
-#include <qobject.h>
-#include <qstring.h>
-
 class QPixmap;
 class Player;
 
@@ -31,14 +28,15 @@
 
 @author Dominik Seichter
 */
-class Card : public QObject {
-    Q_OBJECT
+class Card {
     public:
         // TODO: find better names, Edit bei lenz: done =;-)
-        enum type { /*ASS*/NOSTICH=-1, SAU = 1, ZEHN = 17, KOENIG = 5, OBER = 9, UNTER = 13, NEUN = 21, ACHT = 25, SIEBEN = 29 };
-        enum color { NOCOLOR = -1, EICHEL = 0, GRAS = 1, HERZ = 2, SCHELLEN = 3 };
+        // DS: renamed to avoid name clashes
+        enum EType { /*ASS*/NOSTICH=-1, SAU = 1, ZEHN = 17, KOENIG = 5, OBER = 9, UNTER = 13, NEUN = 21, ACHT = 25, SIEBEN = 29 };
+        enum EColor { NOCOLOR = -1, EICHEL = 0, GRAS = 1, HERZ = 2, SCHELLEN = 3 };
 
-        Card( const enum type t, const enum color c );
+        Card( const int id );
+        Card( const enum EType t, const enum EColor c );
         ~Card();
 
         /** return a pixmap of the card 
@@ -84,10 +82,20 @@
           */
         bool operator<( Card* c );
 
-	bool isEqual(Card* othercard);
+        bool isEqual(Card* othercard);
 
-    private slots:
-        void cardChanged();
+        /** a id(). Using this id the card can be quickly identified
+          * as the id() is calculated using color and type.
+          */
+        int id() const;
+        
+        /** Call this whenever the carddeck has changed and
+          * the internal pixmap should be reloaded.
+          */
+        void cardDeckChanged();
+        
+    private:
+        void init( const enum EType t, const enum EColor c  );
         
     private:
         Player* m_owner;
Index: computerplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/computerplayer.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/computerplayer.h -Lsrc/computerplayer.h -u -r1.13 -r1.14
--- src/computerplayer.h
+++ src/computerplayer.h
@@ -20,8 +20,6 @@
 #ifndef COMPUTERPLAYER_H
 #define COMPUTERPLAYER_H
 
-#include <qobject.h>
-
 #include "player.h"
 #include "card.h"
 #include "gameinfo.h"
@@ -29,9 +27,8 @@
 class OpenBook;
 class CardList;
 
-class ComputerPlayer : public QObject,  public Player
+class ComputerPlayer : public Player
 {
-	Q_OBJECT
     public:
         ComputerPlayer(Game* game);
         ~ComputerPlayer();
@@ -82,7 +79,7 @@
 		int myTrumpfs();
 		int trumpfsInGame();
 				
-	private slots:
+	//private slots:
 		void cardPlayed(unsigned int player, Card *c);
 };
 
Index: settings.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -Lsrc/settings.h -Lsrc/settings.h -u -r1.14 -r1.15
--- src/settings.h
+++ src/settings.h
@@ -56,6 +56,7 @@
 
 
 class Results;
+class QMutex;
 class QWidget;
 
 /**
@@ -72,7 +73,6 @@
         
         const QString cardDeck() const;
         const QString cardBackground() const;
-        QString getCardDir() const;
         
         const QStringList playerNames() const;
         void setPlayerNames( const QStringList & names );
@@ -129,7 +129,9 @@
         ~Settings();
         
         static Settings* m_instance;
-
+        QString getCardDir() const;
+        
+        QMutex* m_mutex;
 };
 
 #endif
Index: gameinfo.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gameinfo.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -Lsrc/gameinfo.h -Lsrc/gameinfo.h -u -r1.11 -r1.12
--- src/gameinfo.h
+++ src/gameinfo.h
@@ -24,6 +24,7 @@
 class CardList;
 class Player;
 class QString;
+
 /**
 Keeps all information on the current game (e.g. wenz or rufspiel)
 
Index: humanplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/humanplayer.cpp,v
retrieving revision 1.25
retrieving revision 1.26
diff -Lsrc/humanplayer.cpp -Lsrc/humanplayer.cpp -u -r1.25 -r1.26
--- src/humanplayer.cpp
+++ src/humanplayer.cpp
@@ -25,12 +25,11 @@
 #include "gamecanvas.h"
 #include "gameinfo.h"
 #include "timer.h"
-#include "selectgamewizard.h"
 
 #include <klocale.h>
 
 HumanPlayer::HumanPlayer(Game* game)
- : QObject( 0, 0 ), Player(game)
+ : Player(game)
 {
     m_allowed = NULL;
     m_card = NULL;
@@ -43,48 +42,70 @@
 
 void HumanPlayer::klopfen()
 {
-    m_geklopft = m_game->canvas()->questionYesNo( i18n("Do you want to double?") );
+    int* ret = (int*)m_game->postEvent( QuestionYesNo, id(), 0, i18n("Do you want to double?"), true );
+    m_geklopft = ( *ret == YES );
+    delete ret;
+    
     Player::klopfen();
 }
 
 Card *HumanPlayer::play()
 {
-   	m_allowed = allowedCards();
-	m_card=NULL;
-    connect( m_game->canvas(), SIGNAL(playCard(Card*)), this, SLOT(getCard(Card*)));
-    ENTER_LOOP();
-	delete m_allowed;
+    int* ret;
+    int cpy;
+    int* cpylist;
+    unsigned int i;
+    
+    m_allowed = allowedCards();
+    m_card=NULL;
+    
+    ret=(int*)m_game->postEvent( HumanPlayerGetCard, id(), NULL, QString::null, true );
+    cpy = *ret;
+    delete ret;
+    
+    while( cpy != -1 && !m_allowed->contains( cpy ) )
+    {
+        cpylist = new int[2];
+        cpylist[0] = cpy;
+        cpylist[1] = 0;
+        m_game->postEvent( ForbiddenCard, id(), cpylist, QString::null, true );
+
+        ret=(int*)m_game->postEvent( HumanPlayerGetCard, id(), NULL, QString::null, true );
+        cpy = *ret;
+        delete ret;
+    }
+    
+    for( i=0;i<m_allowed->count();i++ )
+        if( m_allowed->at(i)->id() == cpy )
+        {
+            m_card = m_allowed->at(i);
+            break;
+        }
+           
+    delete m_allowed;
     m_allowed = NULL;
-    disconnect(m_game->canvas(), SIGNAL(playCard(Card*)), this, SLOT(getCard(Card*)));
     return m_card;
 }
 
 GameInfo* HumanPlayer::gameInfo( bool force )
 {
-    if( force || m_game->canvas()->questionYesNo( i18n("Do you want to play?") ) )
+    if( force )
+    {
+        return (GameInfo*)m_game->postEvent( ForcedSelectGame, id(), m_cards->toIntList(), QString::null, true );
+    }
+    else
     {
-   
-        SelectGameWizard sgw( force, m_cards );
-        if( sgw.exec() == QDialog::Accepted )
-            return sgw.gameInfo();
+        int* ret = (int*)m_game->postEvent( QuestionYesNo, id(), NULL, i18n("Do you want to play?"), true );
+        if( *ret == YES )
+        {
+            delete ret;
+            return (GameInfo*)m_game->postEvent( SelectGame, id(), m_cards->toIntList(), QString::null, true );
+        }
+        else
+            delete ret;
     }
     
     return NULL;
-}
-
-void HumanPlayer::getCard(Card* card)
-{
-    if(!m_game)
-		return;
-	if( m_allowed->containsRef( card ) )
-    {
-        m_card = card;
-        EXIT_LOOP();
-    } 
-	else
-	{
-		m_game->canvas()->cardForbidden(card);
-	}
 }
 
 
Index: computerplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/computerplayer.cpp,v
retrieving revision 1.27
retrieving revision 1.28
diff -Lsrc/computerplayer.cpp -Lsrc/computerplayer.cpp -u -r1.27 -r1.28
--- src/computerplayer.cpp
+++ src/computerplayer.cpp
@@ -28,7 +28,7 @@
 #include <kapplication.h>
 
 ComputerPlayer::ComputerPlayer(Game* game)
-	: QObject(0, 0), Player(game)
+	: Player(game)
 {
 	int i;
 	
@@ -36,7 +36,6 @@
 	for(i=0;i<PLAYERS;i++)
 		m_playedCards[i]=new CardList();
 	m_angespielt=new CardList();
-	connect( m_game, SIGNAL( playerPlayedCard( unsigned int, Card* ) ), this, SLOT( cardPlayed(unsigned int, Card*) ) );
 }
 
 ComputerPlayer::~ComputerPlayer()
@@ -460,6 +459,8 @@
 
 void ComputerPlayer::cardPlayed(unsigned int player, Card *c)
 {
+    // TODO: was called by signal before the thread change
+    // has to be implemented in another way
 	m_playedCards[player]->append(c);
 	if(mitspieler!=-1)
 		return;
@@ -512,4 +513,4 @@
     
     return n2 - n;
 }
-    
\ No newline at end of file
+
Index: cardlist.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/cardlist.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -Lsrc/cardlist.h -Lsrc/cardlist.h -u -r1.11 -r1.12
--- src/cardlist.h
+++ src/cardlist.h
@@ -36,7 +36,12 @@
 {
     public:
         CardList();
-
+        
+        /** Creates a card list from a zero terminated list of integers 
+          * as you can create it using toIntList()
+          */
+        CardList( int* cards );
+        
         /** initialize this card list with a default card
           * deck of 32 cards.
           * The CardList does now own all elements, i.e. they
@@ -60,14 +65,17 @@
           * is in the list
           */
         bool contains( int color, int type );
+        bool contains( int cardid );
         
 		CardList* FindCards(int color, int type);
 		void RemoveCards(CardList* itemsToRem);
 	
 		void sort(eval_func eval, void *param);
 
-	signals:
-		void changeEvent(void);
+        /** creates a zero terminated list of integers, every 
+          * int has the id of one card assigned.
+          */
+        int* toIntList();
 };
 
 #endif
Index: stichdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/stichdlg.cpp,v
retrieving revision 1.6
retrieving revision 1.7
diff -Lsrc/stichdlg.cpp -Lsrc/stichdlg.cpp -u -r1.6 -r1.7
--- src/stichdlg.cpp
+++ src/stichdlg.cpp
@@ -28,10 +28,9 @@
 
 #include <klocale.h>
 
-StichDlg::StichDlg(Game* g,QWidget *parent, const char *name)
+StichDlg::StichDlg(QWidget *parent, const char *name)
     : KDialogBase( KDialogBase::Plain, i18n("Last Trick"),
-      KDialogBase::Close, KDialogBase::Close, parent,name, false),
-      m_game( g)
+      KDialogBase::Close, KDialogBase::Close, parent,name, false)
 {
     QGridLayout* layout = new QGridLayout( plainPage(), 4, 2 );
     trick = new QLabel( plainPage() );
@@ -45,10 +44,7 @@
         layout->addWidget( players[i], 2, i );
     }
     
-    changed( m_game->findIndex( 0 )->id() );
-    
-    connect( m_game, SIGNAL( playerMadeStich(unsigned int)), this, SLOT(changed(unsigned int)));
-    connect( m_game, SIGNAL( gameStarted() ), this, SLOT( reset() ) );
+    reset();
 }
 
 
@@ -56,36 +52,33 @@
 {
 }
 
-void StichDlg::changed( unsigned int id )
+void StichDlg::changed( const QString & name, int* list, QStringList* playerlist )
 {
-    Player* player = m_game->findId( id );
-    CardList* stich = player->stiche();
+    CardList stich( list );
     
-    if( stich && stich->count() )
-        trick->setText( i18n("Trick was made by: <b>") + player->name() + "</b>" );
+    if( stich.count() )
+        trick->setText( i18n("Trick was made by: <b>") + name + "</b>" );
     else
         trick->setText( i18n("No trick was made.") );
         
     for( unsigned int i = 0; i < PLAYERS; i++ )
     {
-        if( stich )
+        if( stich.count() > i ) 
         {
-            if( stich->count() > i ) 
-                cards[i]->setPixmap( *(stich->at( stich->count() - PLAYERS + i )->pixmap()) );
-            else
-                cards[i]->setPixmap( *Card::backgroundPixmap() );
-
-            if( stich->count() > i )
-                players[i]->setText( "<qt><b>"+stich->at( stich->count() - PLAYERS + i )->owner()->name()+"</b></qt>" );
-            else
-                players[i]->setText( m_game->findIndex(i)->name() );
+            cards[i]->setPixmap( *(stich.at( stich.count() - PLAYERS + i )->pixmap()) );
+            players[i]->setText( "<qt><b>"+(*playerlist)[i]+"</b></qt>" );
+        }   
+        else
+        {
+            cards[i]->setPixmap( *Card::backgroundPixmap() );
+            players[i]->setText( QString::null );
         }
     }
 }
 
 void StichDlg::reset()
 {
-    changed( m_game->findIndex( 0 )->id() );
+    changed( 0, NULL, NULL );
 }
 
 #include "stichdlg.moc"
Index: player.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/player.cpp,v
retrieving revision 1.28
retrieving revision 1.29
diff -Lsrc/player.cpp -Lsrc/player.cpp -u -r1.28 -r1.29
--- src/player.cpp
+++ src/player.cpp
@@ -44,28 +44,31 @@
     return m_cards;
 }
 
-void Player::setCards( CardList *cards)
+void Player::setCards( CardList *cards )
 {
     unsigned int i = 0;
+    
     delete m_cards;
     
-    m_has_doubled = false;
     m_geklopft = false;
     
     m_cards=cards;
     // tell the card WHO owns them and WHOM they should serve! ;-)
-    for(i=0;i<cards->count();i++)
+    for(i=0;i<m_cards->count();i++)
         m_cards->at(i)->setOwner( this );
+    
+    m_game->postEvent( PlayerGotCards, id(), m_cards->toIntList() );
 }
 
 void Player::sortCards()
 {
     m_cards->sort((eval_func)m_game->gameInfo()->evalCard, (void *)m_game->gameInfo());
+    m_game->postEvent( PlayerGotCards, id(), m_cards->toIntList() );
 }
 
 void Player::klopfen()
 {
-    m_has_doubled = true;
+    m_game->postEvent( PlayerHasDoubled, id() );
 }
 
 void Player::DebugCardOutput(Card* card)
Index: game.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.h,v
retrieving revision 1.34
retrieving revision 1.35
diff -Lsrc/game.h -Lsrc/game.h -u -r1.34 -r1.35
--- src/game.h
+++ src/game.h
@@ -25,7 +25,8 @@
 #include "cardlist.h"
 #include "gameinfo.h"
 
-#include <qobject.h>
+#include <semaphore.h>
+#include <qthread.h>
 
 class Player;
 class GameCanvas;
@@ -33,11 +34,10 @@
 /**
 @author Dominik Seichter
 */
-class Game : public QObject
+class Game : public QThread
 {
-    Q_OBJECT
     public:
-        Game(QObject *parent = 0, const char *name = 0);
+        Game(sem_t* sem, QObject *parent);
         ~Game();
         void gameLoop();
 		CardList *currStich();
@@ -45,9 +45,6 @@
         inline CardList *playedCards() { return &m_playedcards; }
 		GameInfo *gameInfo();
         
-        void setCanvas( GameCanvas* c );
-        GameCanvas* canvas() const { return m_canvas; }
-        
         Player* findId( unsigned int id ) const;
         Player* findIndex( unsigned int index ) const;
 		bool isTerminated() const { return terminated; }
@@ -58,22 +55,15 @@
           */
         int timesDoubled();
         int timesThrownTogether();
-
-    signals:        
-        void gameStarted();
-        void gameEnded();
-    
-        void playerPlayedCard( unsigned int player, Card* );
-        void playerMadeStich( unsigned int player );
-        void playerResult( const QString & name, const QString & result );
         
-        void signalSetupGameInfo();
-        void signalDoubled();
+        /** post a event to the parent object
+          */
+        void* postEvent( EAction action, unsigned int playerid = 0, int* cardids = NULL, 
+                        QString data = QString::null, bool wait = false, QStringList* names = NULL );
         
-    public slots:
         void endGame(void);
 
-    private slots:
+    private:
         /** set the results of all players to 0. This is necessary
           * if for example the class for the results calculation was changed
           * or when a new game is started.
@@ -88,7 +78,7 @@
     private:
 		/** give cards to the player and begin a new gameinfo
 		 */
-		void start();
+		void startGame();
         /** Display the results of the game (winner/loser)
           * to the user. Called after each game.
           */
@@ -108,8 +98,14 @@
          * to the users settings.
          */
        bool setupGameInfoForced();
-        
+     
+    protected:
+        /** inherited from QThread, calls gameLoop();
+          */
+        void run();
+
     private:
+        sem_t* m_sem;
         bool terminated;
         Player *m_players[PLAYERS];
         CardList m_allcards;
@@ -118,9 +114,8 @@
         GameInfo m_gameinfo;
         int m_laufende;
         int m_timesThrownTogether;
-                
-        GameCanvas *m_canvas;
         
+        QObject* m_parent;
 };
 
 #endif
Index: canvasplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvasplayer.cpp,v
retrieving revision 1.20
retrieving revision 1.21
diff -Lsrc/canvasplayer.cpp -Lsrc/canvasplayer.cpp -u -r1.20 -r1.21
--- src/canvasplayer.cpp
+++ src/canvasplayer.cpp
@@ -29,51 +29,50 @@
 #include <qcanvas.h>
 #include <qfont.h>
 
-CanvasPlayer::CanvasPlayer( QCanvas* canvas )
-    :m_canvas( canvas )
-{
-    create();
-}
-
-CanvasPlayer::CanvasPlayer( int i, Player* player, QCanvas* canvas )
-    : m_player( player ), m_canvas( canvas )
+CanvasPlayer::CanvasPlayer( int i, QCanvas* canvas )
+    : m_canvas( canvas )
 {
     create();
     
-    setPlayer( i, player );
+    m_position = i;
+    // TODO: get a correct id! especially important for networking!
+    m_id = i;
+    m_is_human = (m_id == 0);
 }
 
 CanvasPlayer::~CanvasPlayer()
 {
     unsigned int i = 0;
+    // delete m_items before m_cards
+    // as m_items has references to cards in
+    // m_cards.
     for(i=0;i<NUMCARDS;i++)
         delete m_items[i];
     
+    delete m_cards;
     delete m_name;
 }
 
 void CanvasPlayer::create()
 {
     unsigned int z = 0;
-	for(z=0;z<NUMCARDS;z++)
-	    m_items[z] = new CanvasCard( m_canvas );
+    for(z=0;z<NUMCARDS;z++)
+        m_items[z] = new CanvasCard( m_canvas );
 
-    m_player = NULL;
+    m_cards = new CardList;
+    m_cards->setAutoDelete( true );
+    
     m_name = new QCanvasText( m_canvas );
     m_name->setColor( Qt::white );
     m_name->setFont( QFont( "Helvetica", 24 ) );
     m_name->hide();
-}
-
-void CanvasPlayer::setPlayer( int i, Player* player )
-{
-    m_player = player;
     
-    if( m_player )
-        init(i);    
+    m_is_last = false;
+    m_has_doubled = false;
+    m_player_name = QString::null;
 }
 
-void CanvasPlayer::position( int i )
+void CanvasPlayer::position()
 {
     int x = 0, y = 0;
     int num = 0;
@@ -86,17 +85,18 @@
     
     for( unsigned int z = 0; z < NUMCARDS; z++ )
     {
-    	CanvasCard* card = m_items[z];
+        CanvasCard* card = m_items[z];
         if(card->isVisible())
-		num++;
+            num++;
     }
+    
     if(!Settings::instance()->rearrangeCards())
     	num=NUMCARDS;
     
-    if(i==1||i==3)
+    if(m_position==1||m_position==3)
         qSwap( cardw, cardh );
         
-    switch( i ) 
+    switch( m_position ) 
     {
         case 0:
             if(availw>num*cardw+(num-1))
@@ -141,14 +141,14 @@
 	    card->setDestination( x, y );
 	    card->animatedMove();
 	} 
-        if(i==0)
+        if(m_position==0)
 	{
 	    if(availw>num*cardw+(num-1))
             	x += cardw+1;
 	    else
 	    	x += (availw-cardw)/(num-1);
 	}
-        else if(i==2)
+        else if(m_position==2)
             x += (cardw/6);
         else
             y += (cardh/6);
@@ -156,36 +156,37 @@
     }
         
     // swap them back
-    if(i==1||i==3)
+    if(m_position==1||m_position==3)
         qSwap( cardw, cardh );
 }
 
-void CanvasPlayer::init(int i)
+void CanvasPlayer::init()
 {
-    m_name->setText( m_player->name() );
-    if( !m_player->game()->isTerminated() )
+    m_name->setText( m_player_name );
+
+    if( m_cards->count() )
     {
-        for( unsigned int z = 0; z < m_player->cards()->count(); z++ ) 
+        for( unsigned int z = 0; z < m_cards->count(); z++ ) 
         {
             CanvasCard *c = m_items[z];
-            c->setCard( m_player->cards()->at( z ) );
+            c->setCard( m_cards->at( z ) );
             c->setZ( double(-1 - z) );
             c->show();
             
-            if(i==1)
+            if(m_position==1)
                 c->setRotation(270);
-            else if(i==3)
+            else if(m_position==3)
                 c->setRotation(90);
     #ifdef CHEAT
             c->setFrontVisible( true );
     #else            
-            if( m_player->rtti() == Player::HUMAN )
+            if( m_is_human )
             {
-                if( m_player->hasDoubled() )
+                if( m_has_doubled )
                     c->setFrontVisible( true );
                 else
                 {
-                    if( m_player->isLast() )
+                    if( m_is_last )
                         c->setFrontVisible( z >= 4 );
                     else
                         c->setFrontVisible( z < 4 );
@@ -206,23 +207,58 @@
     }
 }
 
-CanvasCard* CanvasPlayer::hasCard( Card* c ) const
+CanvasCard* CanvasPlayer::hasCard( int cardid ) const
 {
     for(unsigned int i=0;i<NUMCARDS;i++)
     {
         CanvasCard* card = m_items[i];
-        if(card->card() == c)
+        if(card->card()->id() == cardid )
             return card;
     }
-    return 0;
+    return NULL;
 }
         
 void CanvasPlayer::cardPlayed( Card* c )
 {
-    CanvasCard* card = hasCard( c );
+    CanvasCard* card = hasCard( c->id() );
     if( card )
     {
         card->hide();
     }
+}
+
+void CanvasPlayer::setCards( CardList* cards )
+{
+    int i;
+    for( i = 0; i < NUMCARDS; i++ ) 
+        m_items[i]->setCard( NULL );
+
+    m_cards->clear();
+    m_cards->appendList( cards );
+}
+
+void CanvasPlayer::setHasDoubled( bool h )
+{
+    m_has_doubled = h;
+}
+
+void CanvasPlayer::setLast( bool l )
+{
+    m_is_last = l;
+}
+
+void CanvasPlayer::setName( const QString & name )
+{
+    m_player_name = name;
+}
+
+bool CanvasPlayer::isHuman() const
+{
+    return m_is_human;
+}
+
+unsigned int CanvasPlayer::id() const
+{
+    return m_id;
 }
 
Index: pointresults.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/pointresults.cpp,v
retrieving revision 1.8
retrieving revision 1.9
diff -Lsrc/pointresults.cpp -Lsrc/pointresults.cpp -u -r1.8 -r1.9
--- src/pointresults.cpp
+++ src/pointresults.cpp
@@ -46,7 +46,7 @@
     m += m_schneider ? (int)r->schneider : 0;
     m += m_schwarz ? (int)r->schwarz : 0;
     m += m_laufende * (int)r->laufende;
-    m = klopfen( player->game()->timesDoubled(), m );
+    m = (int)klopfen( player->game()->timesDoubled(), m );
     
     if( player == m_gameinfo->spieler() || player == m_gameinfo->mitspieler() )
         m = (m_points > 60 ? m : m * -1);
Index: cardlist.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/cardlist.cpp,v
retrieving revision 1.16
retrieving revision 1.17
diff -Lsrc/cardlist.cpp -Lsrc/cardlist.cpp -u -r1.16 -r1.17
--- src/cardlist.cpp
+++ src/cardlist.cpp
@@ -30,6 +30,18 @@
     setAutoDelete( false );
 }
 
+CardList::CardList( int* cards )
+{
+    setAutoDelete( false );
+
+    if( cards )
+        while( *cards != 0 )
+        {
+            append( new Card( *cards ) );
+            ++cards;
+        }
+}
+
 void CardList::init()
 {
     setAutoDelete( true );
@@ -37,7 +49,7 @@
 
     for( int i = 0; i < CARD_CNT ; i += 4  )
         for( int z = Card::EICHEL; z <= Card::SCHELLEN; z++ )
-            append( new Card( (enum Card::type)(i+1), (enum Card::color)z ) );
+            append( new Card( (Card::EType)(i+1), (Card::EColor)z ) );
 }
 
 int CardList::points()
@@ -104,9 +116,14 @@
 
 bool CardList::contains( int color, int type )
 {
+    return contains( color + type );
+}
+
+bool CardList::contains( int cardid )
+{
     for( unsigned int i = 0; i < this->count(); i++ )
     {
-        if( at(i)->color()==color && at(i)->card()==type )
+        if( at(i)->id() == cardid )
             return true;
     }
     return false;
@@ -150,3 +167,16 @@
 		}
 	}
 }
+
+int* CardList::toIntList()
+{
+    int* list = new int[count()+1];
+    int i;
+    
+    for(i=0;i<count();i++)
+        list[i] = at(i)->id();
+    list[i] = 0;
+    
+    return list;
+}
+
Index: canvasplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvasplayer.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -Lsrc/canvasplayer.h -Lsrc/canvasplayer.h -u -r1.6 -r1.7
--- src/canvasplayer.h
+++ src/canvasplayer.h
@@ -20,7 +20,12 @@
 #ifndef CANVASPLAYER_H
 #define CANVASPLAYER_H
 
+#include "schafkopfdef.h"
+
+#include <qstring.h>
+
 class Card;
+class CardList;
 class CanvasCard;
 class Player;
 class QCanvas;
@@ -33,27 +38,37 @@
 */
 class CanvasPlayer{
     public:
-        CanvasPlayer( QCanvas* canvas );
-        CanvasPlayer( int i, Player* player, QCanvas* canvas );
+        CanvasPlayer( int i, QCanvas* canvas );
         ~CanvasPlayer();
         
-        void position( int i );
-		void init(int i);
+        void position();
+        void init();
+        
+        unsigned int id() const;
+        bool isHuman() const;
         
-        void setPlayer( int, Player* player );
+        void setHasDoubled( bool h );
+        void setLast( bool l );
+        void setName( const QString & name );
+        void setCards( CardList* cards );
         
         void cardPlayed( Card* c );
-        CanvasCard* hasCard( Card* c ) const; 
-        Player* player() const { return m_player; }
+        CanvasCard* hasCard( int cardid ) const; 
         
     private:
         void create();
         
-		QCanvas* m_canvas;
-        QCanvasText* m_name;
-        CanvasCard* m_items[8];
+        unsigned int m_id;
+        int m_position;
+        bool m_has_doubled;
+        bool m_is_last;
+        bool m_is_human;
+        QString m_player_name;
         
-        Player* m_player;
+        QCanvas* m_canvas;
+        QCanvasText* m_name;
+        CanvasCard* m_items[NUMCARDS];
+        CardList* m_cards;
 };
 
 #endif
Index: player.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/player.h,v
retrieving revision 1.22
retrieving revision 1.23
diff -Lsrc/player.h -Lsrc/player.h -u -r1.22 -r1.23
--- src/player.h
+++ src/player.h
@@ -54,12 +54,6 @@
           * count twice or not
           */
         bool geklopft() const { return m_geklopft; }
-        /** required by the user interface to know if all cards
-          * maybe shown or already the first four ones. 
-          * Returns true if the players klopfen() member 
-          * function was already called.
-          */
-        bool hasDoubled() const { return m_has_doubled; }
 
         CardList *allowedCards();
         void removeTrumpf(CardList* liste);
@@ -86,6 +80,7 @@
 		CardList* cardsOfSameType(Card* card);
 		Card* firstPlayedCard();
 		bool istTrumpf(Card* card);
+        
     private:
         static unsigned int def_id;
         double m_points;
Index: schafkopf.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopf.cpp,v
retrieving revision 1.34
retrieving revision 1.35
diff -Lsrc/schafkopf.cpp -Lsrc/schafkopf.cpp -u -r1.34 -r1.35
--- src/schafkopf.cpp
+++ src/schafkopf.cpp
@@ -25,6 +25,8 @@
 #include "player.h"
 #include "newgamewizard.h"
 #include "preferencesdlg.h"
+#include "selectgamewizard.h"
+#include "timer.h"
 
 // for pow()
 #include <math.h>
@@ -33,6 +35,7 @@
 #include <qheader.h>
 #include <qlabel.h>
 #include <qpixmap.h>
+#include <qsemaphore.h>
 #include <qsplitter.h>
 #include <qtable.h>
 #include <qtimer.h>
@@ -54,6 +57,8 @@
 SchafKopf::SchafKopf()
         : KMainWindow( 0, "SchafKopf" )
 {
+    sem_init( &m_sem, 0, 0 );
+    
     split = new QSplitter( QSplitter::Horizontal, this );
 #if QT_VERSION >= 0x030200
     split->setChildrenCollapsible( true );
@@ -66,9 +71,7 @@
     m_canvas = new QCanvas( this, "canvas" );
     m_canvasview = new GameCanvas( m_canvas, split, "canvasview" );
 
-    m_game = new Game();
-    m_game->setCanvas( m_canvasview );
-    m_canvasview->setGame( m_game );
+    m_game = new Game( &m_sem, this );
     m_canvasview->setHScrollBarMode(QScrollView::AlwaysOff);
     m_canvasview->setVScrollBarMode(QScrollView::AlwaysOff);
     
@@ -94,7 +97,6 @@
     lblDoubled = new QLabel( groupInfo );
 
     btnLastTrick = new KPushButton( groupInfo );
-    btnLastTrick->setPixmap( *(Card::backgroundPixmap()) );
     btnLastTrick->setFlat( true );
 
     split->setSizes( Settings::instance()->splitterSizes( width() ) );
@@ -105,32 +107,153 @@
     //connect(kapp, SIGNAL(aboutToQuit()), this, SLOT(endGame()));
 
     connect(btnLastTrick,SIGNAL(clicked()),this,SLOT(showStich()));
-    connect(m_game,SIGNAL(gameStarted()),this,SLOT(enableControls()));
-    connect(m_game,SIGNAL(gameEnded()),this,SLOT(enableControls()));
-    connect(m_game,SIGNAL(signalSetupGameInfo()),this,SLOT(updateInfo()));
-    connect(m_game,SIGNAL(signalDoubled()),this,SLOT(updateInfo()));
-
     connect(Settings::instance(),SIGNAL(resultsTypeChanged()),this,SLOT(clearTable()));
     connect(Settings::instance(),SIGNAL(playerNamesChanged()),this,SLOT(updateTableNames()));
+    connect( Settings::instance(), SIGNAL( cardChanged() ), this, SLOT( updateInfo() ) );
+    
     QToolTip::add
         ( btnLastTrick, i18n("Show the last trick that was made.") );
 
-    m_stichdlg = new StichDlg( m_game, this );            
+    m_stichdlg = new StichDlg( this );            
     
+    m_terminated = true;
+
     updateInfo();
 }
 
 SchafKopf::~SchafKopf()
 {
     saveConfig();
+    // make sure the thread is really not running
+    // and does not wait for the semaphore
+    endGame();
+    sem_destroy( &m_sem );
 
-    //if( m_game )
-    //    endGame();
+    delete m_stichdlg;
+}
 
-    if( m_stichdlg )
-        delete m_stichdlg;
+void SchafKopf::customEvent( QCustomEvent* e )
+{
+    if( e->type() == SCHAFKOPF_EVENT )
+    {
+        int* a;
+        bool force_select = false;
+        
+        t_EventData* data = (t_EventData*)e->data();
+        switch( data->type )
+        {
+            case GameEnded:
+                //EXIT_LOOP();
+                m_canvasview->resetPlayerCards();
+                // fall through!
+
+            case RedrawPlayers:
+                m_canvasview->redrawPlayers();
+                enableControls();
+                break;
+            
+            case GameStarted:
+                m_canvasview->resetPlayers();
+                m_canvasview->redrawPlayers();
+                enableControls();
+                break;
+                        
+            case GameInfoSetup:
+                updateInfo();
+                break;
+                
+            case PlayerIsLast:
+                m_canvasview->playerIsLast( data->playerid );
+                break;
+                
+            case PlayerDoubled:
+                updateInfo();
+                m_canvasview->information( data->data );
+                break;
+                
+            case PlayerHasDoubled:
+                m_canvasview->playerHasDoubled( data->playerid, true );
+                break;
+                
+            case CardPlayed:
+                m_canvasview->slotPlayerPlayedCard( data->playerid, *(data->cardids) );
+                break;
+            
+            case PlayerMadeStich:
+                m_canvasview->slotPlayerMadeStich( data->playerid );
+                m_stichdlg->changed( data->data, data->cardids, data->playernames );
+                break;
+            
+            case PlayerResults:
+                this->slotPlayerResult( data->playerid, data->data );
+                break;
+                
+            case InfoMessage:
+                m_canvasview->information( data->data );
+                break;
+                
+            case QuestionYesNo:
+                a = new int;
+                *a = m_canvasview->questionYesNo( data->data ) ? YES : NO;
+                data->returncode = (void*)a;
+                break;
+            
+            case HumanPlayerGetCard:
+                a = new int;
+                *a = m_canvasview->getCard();
+                data->returncode = (void*)a;
+                break;
+            
+            case ForbiddenCard:
+                m_canvasview->cardForbidden( *(data->cardids) );
+                break;
+            
+            case ForcedSelectGame:
+                force_select = true;
+                // fall through!
+            case SelectGame:
+                data->returncode = (void*)selectGame( force_select, data->cardids );
+                break;
+                
+            case PlayerNameChanged:
+                m_canvasview->setPlayerName( data->playerid, data->data );
+                break;
+                
+            case PlayerGotCards:
+                m_canvasview->setPlayerCards( data->playerid, data->cardids );
+                break;
+                
+            default:
+                break;
+        }
+        
+        data->quitgame = m_terminated;
+        
+        if( data->wait )
+        {
+            sem_post( &m_sem );
+        }
+        else        
+        {
+            // compiler warns that deleting void is undefined....
+            // data->returncode should be NULL anyways...
+            // so why is it there???
+            // stupid comments...
+            if( data->returncode )
+                delete data->returncode;
+                
+            if( data->cardids )
+                delete [] data->cardids;
+
+            if( data->playernames )
+                delete data->playernames;
+                
+            delete data;
+        }
+    }
 }
 
+
 void SchafKopf::saveConfig()
 {
     Settings::instance()->setSplitterSizes( split->sizes() );
@@ -196,26 +319,35 @@
 
 void SchafKopf::realNewGame()
 {
-    connect(m_game,SIGNAL(playerResult(const QString &,const QString &)),this,SLOT(slotPlayerResult(const QString &,const QString &)));
+    //connect(m_game,SIGNAL(playerResult(const QString &,const QString &)),this,SLOT(slotPlayerResult(const QString &,const QString &)));
 
     // entering the game loop is the last thing
     // we want to do!
-    m_game->gameLoop();
-    endGame();    
+    m_terminated = false;
+    m_game->start();
+    //m_game->gameLoop();
+    //endGame();    
 }
 
 void SchafKopf::endGame()
 {
-    disconnect(m_game,SIGNAL(playerResult(const QString &,const QString &)),this,SLOT(slotPlayerResult(const QString &,const QString &)));
+    //disconnect(m_game,SIGNAL(playerResult(const QString &,const QString &)),this,SLOT(slotPlayerResult(const QString &,const QString &)));
 
-    m_game->endGame();
+    //m_game->endGame();
+    if( !m_terminated )
+    {
+        m_terminated = true;
+        EXIT_LOOP();
+        //KApplication::postEvent( m_game, new QCustomEvent( (QEvent::Type)SCHAFKOPF_EVENT_QUIT ) );
+    }
+    
     clearTable();
     updateInfo();
 }
 
 void SchafKopf::showStich()
 {
-    if( m_game->isTerminated() )
+    if( m_terminated )
         return;
 
     m_stichdlg->show();
@@ -228,18 +360,8 @@
     btnLastTrick->setEnabled( !m_game->isTerminated() );
 }
 
-void SchafKopf::slotPlayerResult( const QString & name, const QString & result )
+void SchafKopf::slotPlayerResult( unsigned int col, const QString & result )
 {
-    int col = 0;
-    unsigned int i = 0;
-    QHeader* header = m_table->horizontalHeader();
-    for(;i<(unsigned int)header->count();i++)
-        if(header->label(i) == name )
-        {
-            col = i;
-            break;
-        }
-
     if( !m_table->numRows() || !m_table->text( m_table->numRows()-1, col ).isEmpty() )
         m_table->insertRows( m_table->numRows() );
 
@@ -252,7 +374,9 @@
     int timesDoubled = 0, timesThrownTogether = 0;
     int valuation;
     
-    if( !m_game->isTerminated() && m_game->gameInfo()->isValid() )
+    btnLastTrick->setPixmap( *(Card::backgroundPixmap()) );
+        
+    if( !m_terminated && m_game->gameInfo()->isValid() )
         lblCurGame->setText( i18n("<qt>Current Game:<br><b>") + m_game->gameInfo()->toString() + "</b></qt>" );
     else
     {
@@ -274,9 +398,9 @@
     timesThrownTogether = m_game->timesThrownTogether();
     if(timesThrownTogether>0)
         sDoubled.append( i18n("<qt>Times thrown together: <b>%1</b></qt>").arg(timesThrownTogether) );
-    valuation=pow(2, timesDoubled);
+    valuation=(int)pow(2, timesDoubled);
     if( Settings::instance()->doubleNextGame() )
-        valuation = valuation * pow(2, timesThrownTogether );
+        valuation = valuation * (int)pow(2, timesThrownTogether );
     sDoubled.append( i18n("<qt>Game counts <b>%1-fold</b>.</qt>").arg(valuation) );
     
     lblDoubled->setText( sDoubled );
@@ -297,13 +421,25 @@
     PreferencesDlg prefs( this, "prefs");
     if( prefs.exec() == QDialog::Accepted )
     {
-    m_canvasview->updateBackground();
+        m_canvasview->updateBackground();
     }
 }
 
 void SchafKopf::updateTableNames()
 {
     m_table->setColumnLabels( Settings::instance()->playerNames() );
+}
+
+GameInfo* SchafKopf::selectGame( bool force, int* cardids )
+{
+    CardList list( cardids );
+    list.setAutoDelete( true );
+    
+    SelectGameWizard sgw( force, &list );    
+    if( sgw.exec() == QDialog::Accepted )
+        return sgw.gameInfo();
+    else
+        return NULL;
 }
 
 #include "schafkopf.moc"
Index: humanplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/humanplayer.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -Lsrc/humanplayer.h -Lsrc/humanplayer.h -u -r1.12 -r1.13
--- src/humanplayer.h
+++ src/humanplayer.h
@@ -20,24 +20,19 @@
 #ifndef HUMANPLAYER_H
 #define HUMANPLAYER_H
 
-#include <qobject.h>
 #include "player.h"
 
-class HumanPlayer : public QObject, public Player
+class HumanPlayer : public Player
 {
-    Q_OBJECT
-	public:
+    public:
         HumanPlayer(Game* game);
         ~HumanPlayer();
         
-		void klopfen();
+        void klopfen();
         Card *play();
         GameInfo* gameInfo( bool force = false );
         
-		int rtti() const { return HUMAN; }        
-
-    private slots:
-        void getCard( Card* card );
+        int rtti() const { return HUMAN; }        
         
     private:
         Card* m_card;
Index: canvascard.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -Lsrc/canvascard.h -Lsrc/canvascard.h -u -r1.11 -r1.12
--- src/canvascard.h
+++ src/canvascard.h
@@ -32,7 +32,6 @@
 	Q_OBJECT
     public:
         CanvasCard(QCanvas*c);
-        CanvasCard(Card* card,QCanvas*c);
         ~CanvasCard();
 
         void setCard(Card* card);
@@ -71,6 +70,7 @@
 	private slots:
 		void disableForbidden();
 		void moveLoop();
+        void cardDeckChanged();
 };
 
 #endif
Index: stichdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/stichdlg.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -Lsrc/stichdlg.h -Lsrc/stichdlg.h -u -r1.5 -r1.6
--- src/stichdlg.h
+++ src/stichdlg.h
@@ -24,7 +24,6 @@
 
 #include <kdialogbase.h>
 
-class Game;
 class QLabel;
 /**
 Show the last trick which was made
@@ -38,19 +37,18 @@
 {
     Q_OBJECT
     public:
-        StichDlg(Game* g, QWidget *parent = 0, const char *name = 0);
+        StichDlg(QWidget *parent = 0, const char *name = 0);
         ~StichDlg();
         
-    private slots:
-        void changed(unsigned int id);
+        void changed( const QString & name, int* list, QStringList* players );
+        
+    private:
         void reset();
         
     private:
         QLabel* trick;
         QLabel* cards[PLAYERS];
         QLabel* players[PLAYERS];
-            
-        Game* m_game;
 };
 
 #endif
Index: settings.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.cpp,v
retrieving revision 1.18
retrieving revision 1.19
diff -Lsrc/settings.cpp -Lsrc/settings.cpp -u -r1.18 -r1.19
--- src/settings.cpp
+++ src/settings.cpp
@@ -29,6 +29,8 @@
 #include <kuser.h>
 #include <kstandarddirs.h>
 
+#include <qmutex.h>
+
 Settings* Settings::m_instance = 0;
 
 Settings* Settings::instance() 
@@ -42,16 +44,21 @@
 Settings::Settings(QObject *parent, const char *name)
  : QObject(parent, name)
 {
+    // the mutex causes more problems right now than be useful...
+    m_mutex = NULL; // new QMutex();
 }
 
 
 Settings::~Settings()
 {
+    delete m_mutex;
     delete m_instance;
 }
 
 const QString Settings::cardDeck() const
 {
+    QMutexLocker locker( m_mutex );
+    
     QString cardDir = getCardDir()+"cards-bavarian-old/";
     KConfig* config = kapp->config();
     config->setGroup("CardDeck");
@@ -62,6 +69,8 @@
 
 const QString Settings::cardBackground() const
 {
+    QMutexLocker locker( m_mutex );
+
     QString deckCard = getCardDir()+"decks/bavaria_tux.png";
     KConfig* config = kapp->config();
     config->setGroup("CardDeck");
@@ -72,6 +81,8 @@
 
 QString Settings::getCardDir() const
 {
+    // do not lock private members
+    
     QString dir = KCardDialog::getDefaultCardDir();
     int k;
     dir = dir.remove( dir.length()-1, 1 );
@@ -82,23 +93,28 @@
 
 void Settings::configureCardDecks( QWidget* parent )
 {
+    // no mutex locker here as we would lock cardDeck and cardBackground
+    
     QString dir = cardDeck();
     QString deck = cardBackground();
         
     if (KCardDialog::getCardDeck(deck, dir, parent, KCardDialog::Both ) == QDialog::Accepted)
     {
+        //m_mutex->lock();
         KConfig* config = kapp->config();
         config->setGroup("CardDeck");
         config->writeEntry( "Cards", dir );
         config->writeEntry( "Deck", deck );
         kapp->config()->sync();
-        
+        //m_mutex->unlock();
         emit cardChanged();
     }
 }
 
 const QStringList Settings::playerNames() const
 {
+    QMutexLocker locker( m_mutex );
+    
     QStringList list;
     KUser user;
     KConfig* config = kapp->config();
@@ -112,6 +128,8 @@
 
 void Settings::setPlayerNames( const QStringList & names )
 {
+    QMutexLocker locker( m_mutex );
+
     int i;
     KConfig* config = kapp->config();
     QStringList old = this->playerNames();
@@ -126,6 +144,8 @@
 
 QValueList<int> Settings::splitterSizes( int width )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     QValueList<int> list;
     
@@ -142,6 +162,8 @@
 
 void Settings::setSplitterSizes( QValueList<int> list )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->writeEntry( "Splitter", list );
     config->sync();
@@ -149,6 +171,8 @@
 
 void Settings::setResultsType( int r )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup( "SchafKopf" );
     config->writeEntry("ResultMode", r );
@@ -159,6 +183,8 @@
 
 int Settings::resultsType() const
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup( "SchafKopf" );
     return config->readNumEntry("ResultMode", MONEY );
@@ -166,6 +192,8 @@
 
 Results* Settings::results() const
 {
+    QMutexLocker locker( m_mutex );
+    
     int r = resultsType();
     if( r == MONEY )
         return new MoneyResults();
@@ -177,6 +205,8 @@
 
 void Settings::setMoneyResults( const t_ResultValues* r )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup( "MoneyValues" );
     config->writeEntry( "Solo", r->solo );
@@ -189,6 +219,8 @@
 
 void Settings::setPointResults( const t_ResultValues* r )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup( "PointValues" );
     config->writeEntry( "Solo", (int)r->solo );
@@ -201,6 +233,8 @@
 
 t_ResultValues* Settings::moneyResults() const
 {
+    QMutexLocker locker( m_mutex );
+    
     t_ResultValues* r = new t_ResultValues;
     KConfig* config = kapp->config();
     config->setGroup( "MoneyValues" );
@@ -214,6 +248,8 @@
 
 t_ResultValues* Settings::pointResults() const
 {
+    QMutexLocker locker( m_mutex );
+
     t_ResultValues* r = new t_ResultValues;
     KConfig* config = kapp->config();
     config->setGroup( "PointValues" );
@@ -227,6 +263,8 @@
 
 void Settings::setNoGame( int e )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
     config->writeEntry( "KeinSpiel", e );
@@ -235,6 +273,8 @@
 
 int Settings::noGame() const
 {
+    QMutexLocker locker( m_mutex );
+    
     int e = NOGAME_NEUGEBEN;
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
@@ -245,6 +285,8 @@
 
 void Settings::setDoublerHasToPlay( bool b )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
     config->writeEntry( "DoublerHasToPlay", b );
@@ -253,6 +295,8 @@
 
 bool Settings::doublerHasToPlay() const
 {
+    QMutexLocker locker( m_mutex );
+    
     bool b = true;
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
@@ -262,6 +306,8 @@
 
 void Settings::setDoubleNextGame( bool b )
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
     config->writeEntry( "DoubleNextGame", b );
@@ -270,6 +316,8 @@
 
 bool Settings::doubleNextGame() const
 {
+    QMutexLocker locker( m_mutex );
+    
     bool b = true;
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
@@ -279,6 +327,8 @@
 
 void Settings::setRearrangeCards( bool b)
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
     config->writeEntry( "RearrangeCards", b );
@@ -287,6 +337,8 @@
 
 bool Settings::rearrangeCards() const
 {
+    QMutexLocker locker( m_mutex );
+    
     bool b = true;
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
@@ -296,6 +348,8 @@
 
 void Settings::setBackgroundImage( QString b)
 {
+    QMutexLocker locker( m_mutex );
+    
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
     config->writeEntry( "backgroundImage", b );
@@ -305,6 +359,7 @@
 
 QString Settings::backgroundImage() const
 {
+    QMutexLocker locker( m_mutex );
     QString b="";
     KConfig* config = kapp->config();
     config->setGroup("SchafKopf");
@@ -315,6 +370,7 @@
 
 t_AllowedGames* Settings::allowedGames() const
 {
+    QMutexLocker locker( m_mutex );
     t_AllowedGames* a = new t_AllowedGames;
     
     KConfig* config = kapp->config();
@@ -330,6 +386,7 @@
 
 void Settings::setAllowedGames( const t_AllowedGames* allowed )
 {
+    QMutexLocker locker( m_mutex );
     KConfig* config = kapp->config();
     config->setGroup( "Games" );
     config->writeEntry( "AllowWenz", allowed->wenz );
Index: schafkopf.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopf.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -Lsrc/schafkopf.h -Lsrc/schafkopf.h -u -r1.10 -r1.11
--- src/schafkopf.h
+++ src/schafkopf.h
@@ -28,15 +28,19 @@
 #include <kmainwindow.h>
 #include <qguardedptr.h> 
 
-class StichDlg;
+#include <semaphore.h>
+
+class CardList;
 class GameCanvas;
 class Game;
+class GameInfo;
 class KAction;
 class KPushButton;
 class QCanvas;
 class QLabel;
 class QSplitter;
 class QTable;
+class StichDlg;
 
 /**
  * @short Application Main Window
@@ -77,7 +81,7 @@
         
 		void realNewGame();
         
-        void slotPlayerResult( const QString & name, const QString & result );
+        void slotPlayerResult( unsigned int id, const QString & result );
         
         void saveConfig();
         
@@ -91,8 +95,18 @@
           * in the preferences
           */
         void updateTableNames();
+        
+    protected:
+        /** Event handler to receive thread events
+          */
+        void customEvent( QCustomEvent* e );
+        
     private:
         void setupActions();
+        GameInfo* selectGame( bool force, int* cardids );
+
+        bool m_terminated;
+        sem_t m_sem;
         
         Game* m_game;
         GameCanvas* m_canvasview;
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.14
retrieving revision 1.15
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.14 -r1.15
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -33,21 +33,14 @@
 CanvasCard::CanvasCard(QCanvas*c)
  : QCanvasRectangle(c), m_rotation(0)
 {
-    m_card = 0;
+    m_card = NULL;
     m_forbidden = false;
     show();
     timer = new QTimer( this );
     loadOK1 = Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
     loadOK2 = Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
-}
-
-CanvasCard::CanvasCard(Card* card,QCanvas*c)
- : QCanvasRectangle(c), m_rotation(0)
-{
-    setCard( card );
-    m_forbidden = false;
-    show();
-    //timer = new QTimer( this );
+    
+    connect( Settings::instance(), SIGNAL( cardChanged() ), this, SLOT( cardDeckChanged() ) );
 }
 
 CanvasCard::~CanvasCard()
@@ -138,4 +131,13 @@
 		timer->stop();
 		disconnect( timer, SIGNAL(timeout()), this, SLOT(moveLoop()) );
 	}
+}
+
+void CanvasCard::cardDeckChanged()
+{
+    if( m_card )
+    {
+        m_card->cardDeckChanged();
+        QCanvasItem::update();
+    }
 }
Index: selectgametypebox.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/selectgametypebox.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -Lsrc/selectgametypebox.cpp -Lsrc/selectgametypebox.cpp -u -r1.9 -r1.10
--- src/selectgametypebox.cpp
+++ src/selectgametypebox.cpp
@@ -132,7 +132,7 @@
 	GameInfo* info = gameInfo();
 
 	list.init();
-	for(i=0;i<list.count();i++)
+	for(i=0;i<(int)list.count();i++)
 		if( info->istTrumpf( list.at(i) ) )
 			trumpf.append( list.at(i) );
 	delete info;
@@ -143,7 +143,7 @@
 	x=c.pixmap()->width()/2*(trumpf.count()-1);
 	pix.fill( Qt::darkGreen );
 	QPainter p( &pix );
-	for(i=0;i<=trumpf.count()-1;i++)
+	for(i=0;i<=(int)trumpf.count()-1;i++)
 	{
 		QPixmap* pixmap = trumpf.at(i)->pixmap();
 		p.drawPixmap( x, y, *pixmap );
Index: game.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.cpp,v
retrieving revision 1.68
retrieving revision 1.69
diff -Lsrc/game.cpp -Lsrc/game.cpp -u -r1.68 -r1.69
--- src/game.cpp
+++ src/game.cpp
@@ -29,19 +29,20 @@
 #include "pointresults.h"
 
 #include "settings.h"
-#include "timer.h"
 
+#include <kapplication.h>
 #include <klocale.h>
 #include <kmessagebox.h>
 #include <string.h>
 
-Game::Game(QObject *parent, const char *name)
- : QObject(parent, name)
+Game::Game(sem_t* sem, QObject *parent )
+ : QThread()
 {
     unsigned int i;
     terminated = true;
+    m_sem = sem;
     
-    m_canvas = NULL;
+    m_parent = parent;
     m_laufende = 0;
     m_timesThrownTogether = 0;
     
@@ -54,8 +55,10 @@
     updatePlayerNames();
     
     // make sure that results get cleaned up, when the results type is changed
+    /*
     connect( Settings::instance(), SIGNAL( resultsTypeChanged() ), this, SLOT( resetGameResults() ) );
     connect( Settings::instance(), SIGNAL( playerNamesChanged() ), this, SLOT( updatePlayerNames() ) );
+    */
 }
 
 Game::~Game()
@@ -70,7 +73,12 @@
 	}
 }
 
-void Game::start()
+void Game::run()
+{
+    gameLoop();
+}
+
+void Game::startGame()
 {
     unsigned int i = 0;
     CardList *playercards[PLAYERS];
@@ -86,7 +94,9 @@
         m_players[i]->setCards( playercards[i] );
         m_players[i]->stiche()->clear();
     }
-	emit gameStarted();
+
+    postEvent( GameStarted );
+    //emit gameStarted();
 }
 
 // Wer hat den ganzen rekursiven code in gameLoop zu veantworten? Bitter sofort erschie???n :)
@@ -95,8 +105,8 @@
     int i, a, index, realindex;
     Player *tmp[PLAYERS];
 	Card *c=NULL;
-    Timer timer;
 	int gamecnt=0;
+    QStringList* playernames = NULL;
     
 	terminated = false;
 
@@ -104,17 +114,18 @@
     
 	while(!terminated)
 	{
+        startGame();
+		
+        // setLast() has to be done after startGame(),
+        // so that CanvasPlayer draws cards correctly for
+        // doubling when gameStarted is emited.
 		for(i=0;i<PLAYERS;i++)
         {
 			tmp[i]=m_players[(i+gamecnt)%PLAYERS];
-            tmp[i]->setLast( (i==PLAYERS-1) );
+            if( (i==PLAYERS-1) )
+                postEvent( PlayerIsLast, tmp[i]->id() );
+            //tmp[i]->setLast( (i==PLAYERS-1) );
         }
-		// setLast() has to be done before start(),
-        // so that CanvasPlayer draws cards correctly for
-        // doubling when gameStarted is emited.
-        // otherwise we had to emit gameStarted twice which would 
-        // result in an ugly UI rebuild
-        start();
         
 		for(i=0;i<PLAYERS;i++)
 		{
@@ -122,14 +133,15 @@
 	        tmp[i]->sortCards();
         	if( tmp[i]->geklopft() && tmp[i]->rtti() != Player::HUMAN ) 
         	{
-            	m_canvas->information( i18n("%1 has doubled.").arg( tmp[i]->name() ) );
-            	emit signalDoubled();
+            	//m_canvas->information( i18n("%1 has doubled.").arg( tmp[i]->name() ) );
+                postEvent( PlayerDoubled, tmp[i]->id(), 0, i18n("%1 has doubled.").arg( tmp[i]->name() ), true );
+            	// emit signalDoubled();
         	}
 			if(terminated)
 				return;
 		}
     
-    	m_canvas->redrawPlayers();
+    	postEvent( RedrawPlayers );
     
     	// find a player you can playercards
     	// and setup m_gameinfo    
@@ -140,7 +152,8 @@
 			tmp[i]->sortCards();
 			tmp[i]->init();
 		}
-    	m_canvas->redrawPlayers();
+    	
+    	postEvent( RedrawPlayers );
 
     	for(i=0;i<TURNS ;i++)
 	    {
@@ -163,14 +176,27 @@
 	    		}
             
        	    	m_currstich.append(c);
-            	emit playerPlayedCard(tmp[a]->id(),c);
-            	timer.block( 1 );
+                int* cards = new int[2];
+                cards[0] = c->id();
+                cards[1] = 0;
+                postEvent( CardPlayed, tmp[a]->id(), cards, QString::null, true );
+            	//emit playerPlayedCard(tmp[a]->id(),c);
+                
+            	sleep( 1 );
 				if( terminated )
 					return;
         	}
 			index = highestCard();
     	    tmp[index]->addStich( m_currstich );
-        	emit playerMadeStich(tmp[index]->id());
+            
+            playernames = new QStringList();
+            for(a=0;a<PLAYERS;a++)
+                playernames->append( m_currstich.at(a)->owner()->name() );
+                
+        	postEvent( PlayerMadeStich, tmp[index]->id(), m_currstich.toIntList(),
+                       tmp[index]->name(), false, playernames );
+                       
+            //emit playerMadeStich(tmp[index]->id());
         	// Sortiere so, das der stecher n???hste karte spielt 
 			for(realindex=0;realindex<PLAYERS;realindex++)
 				if(m_players[realindex]==tmp[index])
@@ -193,8 +219,9 @@
 void Game::endGame(void)
 {
 	terminated=true;
-	emit gameEnded();
-	EXIT_LOOP();
+    postEvent( GameEnded );
+	//emit gameEnded();
+	//EXIT_LOOP();
 }
 
 /*const*/ GameInfo *Game::gameInfo() //const
@@ -202,11 +229,6 @@
     return &m_gameinfo;
 }
 
-void Game::setCanvas( GameCanvas* c )
-{
-    m_canvas = c;
-}
-
 Player* Game::findId( unsigned int id ) const
 {     
     for( unsigned int i = 0; i < PLAYERS; i++)
@@ -282,8 +304,13 @@
     r->setLaufende( m_laufende );
     r->setGameInfo( &m_gameinfo );
     for( unsigned int i=0;i<PLAYERS;i++)
-        emit playerResult( m_players[i]->name(), r->formatedPoints(m_players[i])  );
-    m_canvas->information( r->result() );
+    {
+        postEvent( PlayerResults, m_players[i]->id(), 0, r->formatedPoints(m_players[i]), true );
+        // emit playerResult( m_players[i]->name(), r->formatedPoints(m_players[i])  );
+    }
+      
+    postEvent( InfoMessage, 0, 0, r->result(), true );
+    //m_canvas->information( r->result() );
     delete r;
     m_timesThrownTogether = 0;
     
@@ -310,12 +337,14 @@
 			info->setSpieler( players[i] );
             games.append( info );
             if( players[i]->rtti() != Player::HUMAN )
-                m_canvas->information( i18n("%1 has a game.").arg( players[i]->name() ) );
+                postEvent( InfoMessage, 0, 0, i18n("%1 has a game.").arg( players[i]->name() ), true );
+                //m_canvas->information( i18n("%1 has a game.").arg( players[i]->name() ) );
         }
         else
         {
             if( players[i]->rtti() != Player::HUMAN )
-                m_canvas->information( i18n("%1 has no game.").arg( players[i]->name() ) );
+                postEvent( InfoMessage, 0, 0, i18n("%1 has no game.").arg( players[i]->name() ), true );
+                //m_canvas->information( i18n("%1 has no game.").arg( players[i]->name() ) );
         }
     }
     
@@ -341,7 +370,7 @@
     // finde den mitspieler:
     if( m_gameinfo.mode()==GameInfo::RUFSPIEL ) 
     {
-        Card sau( Card::SAU, static_cast<enum Card::color>(m_gameinfo.color()) );
+        Card sau( Card::SAU, static_cast<Card::EColor>(m_gameinfo.color()) );
         for( i=0;i<PLAYERS || !m_gameinfo.mitspieler();i++ )
         {
             for( unsigned int z=0;z<CARD_CNT/PLAYERS;z++ )
@@ -354,10 +383,12 @@
     }
     
     m_laufende = m_gameinfo.laufende();
-    m_canvas->information( m_gameinfo.toString() );
+    postEvent( InfoMessage, 0, 0, m_gameinfo.toString(), true );
+    //m_canvas->information( m_gameinfo.toString() );
 
     m_gameinfo.setValid( true );
-    emit signalSetupGameInfo();
+    postEvent( GameInfoSetup );
+    //emit signalSetupGameInfo();
     return true;
 }
 
@@ -373,7 +404,8 @@
         for( i=PLAYERS-1;i>=0;i-- )
             if( m_players[i]->geklopft() )
             {
-                m_canvas->information( i18n("%1 has doubled last\nand has to play now.").arg( m_players[i]->name() ) );
+                postEvent( InfoMessage, 0, 0, i18n("%1 has doubled last\nand has to play now.").arg( m_players[i]->name() ), true );
+                //m_canvas->information( i18n("%1 has doubled last\nand has to play now.").arg( m_players[i]->name() ) );
     
                 info = m_players[i]->gameInfo( true );
                 info->setSpieler( m_players[i] );
@@ -385,10 +417,12 @@
         
     if( Settings::instance()->noGame() == Settings::NOGAME_NEUGEBEN )
     {
-        m_canvas->information( i18n("No one wants to play.\nCards will be thrown together.") );
+        postEvent( InfoMessage, 0, 0, i18n("No one wants to play.\nCards will be thrown together."), true );
+        //m_canvas->information( i18n("No one wants to play.\nCards will be thrown together.") );
         m_timesThrownTogether++;
         m_gameinfo.setValid( false );
-        emit signalSetupGameInfo();
+        postEvent( GameInfoSetup );
+        //emit signalSetupGameInfo();
         return false;
     }
     else if( Settings::instance()->noGame() == Settings::NOGAME_ALTERSPIELT )
@@ -397,7 +431,8 @@
         for( i=0;i<PLAYERS;i++ )
             if( m_players[i]->cards()->contains( Card::EICHEL, Card::OBER ) )
             {
-                m_canvas->information( i18n("%1 has got the Eichel Ober\nand has to play.").arg( m_players[i]->name() ) );
+                postEvent( InfoMessage, 0, 0, i18n("%1 has got the Eichel Ober\nand has to play.").arg( m_players[i]->name() ), true );
+                //m_canvas->information( i18n("%1 has got the Eichel Ober\nand has to play.").arg( m_players[i]->name() ) );
                 
                 info = m_players[i]->gameInfo( true );
                 info->setSpieler( m_players[i] );
@@ -441,11 +476,51 @@
     int i;
     QStringList list = Settings::instance()->playerNames();
     m_players[0]->setName( list[0] );
+    postEvent( PlayerNameChanged, m_players[0]->id(), 0, list[0] );
+    
     for( i=1;i<PLAYERS;i++)
+    {
         m_players[i]->setName( list[i] );
+        postEvent( PlayerNameChanged, m_players[i]->id(), 0, list[i] );
+    }
+       
+    postEvent( RedrawPlayers );
+    //m_canvas->redrawPlayers();
+}
+
+void* Game::postEvent( EAction action, unsigned int playerid, int* cardids, QString d, bool wait, QStringList* names )
+{
+    t_EventData* data = new t_EventData;
+    void* ret = NULL;
+    
+    data->type = action;
+    data->playerid = playerid;
+    data->cardids = cardids;
+    data->data = d;
+    data->wait = wait;
+    data->playernames = names;
+    data->returncode = NULL;
+    data->quitgame = false;
+    
+    KApplication::postEvent( m_parent, new QCustomEvent( (QEvent::Type)SCHAFKOPF_EVENT, (void*)data) );
+    if( wait )
+    {
+        sem_wait( m_sem );
+            
+        if( data->quitgame )
+            endGame();
+
+        ret = data->returncode;
         
-    if( m_canvas )
-        m_canvas->redrawPlayers();
+        if( data->cardids )
+            delete [] data->cardids;
+                
+        if( data->playernames )
+            delete data->playernames;
+            
+        delete data;
+    }
+    
+    return ret;
 }
 
-#include "game.moc"

From schafkopf-devel at berlios.de  Sun Feb 13 14:53:21 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sun, 13 Feb 2005 14:53:21 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf kleiner bugix
Message-ID: <200502131353.j1DDrLTY015748@sheep.berlios.de>

Log Message:
-----------
kleiner bugix

Modified Files:
--------------
    schafkopf:
        TODO
    schafkopf/src:
        preferencesdlg.cpp

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.7
retrieving revision 1.8
diff -LTODO -LTODO -u -r1.7 -r1.8
--- TODO
+++ TODO
@@ -1,2 +1,11 @@
 
-Rufsau nach davonlaufen in allowedCards hinzuf?gen
+Fixen:
+- Umstellen der Spielkarten (und R?ckseite) f?hrt zu Darstellungsfehler
+- Rufsau nach davonlaufen in allowedCards hinzuf?gen
+
+neue Features:
+- Tastatursteuerung
+- "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realit?t kann ich es davon abh?ngig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralit?t stattfindet." Und dann nur Spiele ausw?hlbar machen die h?her sind als die vorher angesagten.
+- AI verbessern
+- richtige Schafkopfkarten hinzuf?gen
+- netzwerktransparente Kommunikation (f?r neuronales Netzwerk)
\ No newline at end of file
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.18
retrieving revision 1.19
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.18 -r1.19
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -282,6 +282,7 @@
     layout->addWidget( group2 );
     layout->addWidget( group );
     layout->addItem( spacer );
+    disableClearButton(m_linePathBackground->url());
     
     connect( m_pushURLClear, SIGNAL( clicked() ), m_linePathBackground, SLOT( clear() ) );
     connect( m_linePathBackground, SIGNAL( textChanged(const QString &) ), this, SLOT( disableClearButton(const QString &) ) );

From schafkopf-devel at berlios.de  Sun Feb 13 15:15:55 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sun, 13 Feb 2005 15:15:55 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf stiche verschwinden nicht mehr beim karten
Message-ID: <200502131415.j1DEFt7s016515@sheep.berlios.de>

Log Message:
-----------
stiche verschwinden nicht mehr beim karten deck wechsel

Modified Files:
--------------
    schafkopf/src:
        canvascard.cpp
        gamecanvas.cpp
        humanplayer.cpp

-------------- next part --------------
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.42
retrieving revision 1.43
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.42 -r1.43
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -72,7 +72,6 @@
     canvas()->setAdvancePeriod( 20 );
     update();
     
-    connect( Settings::instance(), SIGNAL(cardChanged()), this, SLOT(redrawPlayers()));
     connect( Settings::instance(), SIGNAL(cardChanged()), this, SLOT(positionObjects()));
     connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(yesNoClicked(QCanvasItem*)));
 }    
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.15
retrieving revision 1.16
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.15 -r1.16
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -19,7 +19,6 @@
  ***************************************************************************/
 #include "canvascard.h"
 #include "card.h"
-#include "timer.h"
 #include "settings.h"
 
 #include <qpainter.h>
Index: humanplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/humanplayer.cpp,v
retrieving revision 1.26
retrieving revision 1.27
diff -Lsrc/humanplayer.cpp -Lsrc/humanplayer.cpp -u -r1.26 -r1.27
--- src/humanplayer.cpp
+++ src/humanplayer.cpp
@@ -24,7 +24,6 @@
 #include "game.h"
 #include "gamecanvas.h"
 #include "gameinfo.h"
-#include "timer.h"
 
 #include <klocale.h>
 

From schafkopf-devel at berlios.de  Sun Feb 13 15:18:36 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sun, 13 Feb 2005 15:18:36 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf alpha-karte aendert sich jetzt beim
Message-ID: <200502131418.j1DEIajl016718@sheep.berlios.de>

Log Message:
-----------
alpha-karte aendert sich jetzt beim karten-deck wechsel

Modified Files:
--------------
    schafkopf/src:
        canvascard.cpp
        canvascard.h

-------------- next part --------------
Index: canvascard.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.h,v
retrieving revision 1.12
retrieving revision 1.13
diff -Lsrc/canvascard.h -Lsrc/canvascard.h -u -r1.12 -r1.13
--- src/canvascard.h
+++ src/canvascard.h
@@ -71,6 +71,7 @@
 		void disableForbidden();
 		void moveLoop();
         void cardDeckChanged();
+        void loadAlpha();
 };
 
 #endif
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.16
retrieving revision 1.17
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.16 -r1.17
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -36,9 +36,8 @@
     m_forbidden = false;
     show();
     timer = new QTimer( this );
-    loadOK1 = Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
-    loadOK2 = Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
-    
+    loadAlpha();
+        
     connect( Settings::instance(), SIGNAL( cardChanged() ), this, SLOT( cardDeckChanged() ) );
 }
 
@@ -132,11 +131,18 @@
 	}
 }
 
+void CanvasCard::loadAlpha()
+{
+    loadOK1 = Shadow.load( Settings::instance()->cardDeck() + "alpha1.png" );
+    loadOK2 = Shadow2.load( Settings::instance()->cardDeck() + "alpha2.png" );
+}
+
 void CanvasCard::cardDeckChanged()
 {
     if( m_card )
     {
         m_card->cardDeckChanged();
+        loadAlpha();
         QCanvasItem::update();
     }
 }

From schafkopf-devel at berlios.de  Mon Feb 14 17:37:22 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 14 Feb 2005 17:37:22 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf TODO-Liste aktualisiert
Message-ID: <200502141637.j1EGbMgk001898@sheep.berlios.de>

Log Message:
-----------
TODO-Liste aktualisiert

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.8
retrieving revision 1.9
diff -LTODO -LTODO -u -r1.8 -r1.9
--- TODO
+++ TODO
@@ -1,11 +1,20 @@
-
 Fixen:
-- Umstellen der Spielkarten (und R?ckseite) f?hrt zu Darstellungsfehler
 - Rufsau nach davonlaufen in allowedCards hinzuf?gen
 
+AI:
+- Solo: Mitspieler schmieren dem Spieler
+- Solo: Spieler spielt seine Tr?mpfe zu sp?t.
+- Computer schmiert auch Ober wenn er nix h?heres hat
+- ?fters Rufspiele spielen
+- "Wird eine Farbe das zweite Mal gespielt, so sollte ein AI-Spieler mindestens mit einem Unter stechen, sofern hinter ihm noch ein Gegner kommt." (auf keinen Fall schmieren!!)
+- "Als Spieler nicht die Sau suchen, sondern Trumpf ausspielen"
+
 neue Features:
 - Tastatursteuerung
 - "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realit?t kann ich es davon abh?ngig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralit?t stattfindet." Und dann nur Spiele ausw?hlbar machen die h?her sind als die vorher angesagten.
-- AI verbessern
 - richtige Schafkopfkarten hinzuf?gen
-- netzwerktransparente Kommunikation (f?r neuronales Netzwerk)
\ No newline at end of file
+- netzwerktransparente Kommunikation (f?r neuronales Netzwerk und Netzwerkspiel)
+- speichern und laden von Spielen
+- Trainingsmodus mit "R?ckg?ngig"-Funktion (auch mehrere Stiche)
+- "Letzter Stich"-Dialog: Karten so anordnen wie auf dem Spielfeld
+- Kontra, Reh, ...

From schafkopf-devel at berlios.de  Tue Feb 15 15:47:49 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Tue, 15 Feb 2005 15:47:49 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Einige Klassen fr die
Message-ID: <200502151447.j1FElnIe006077@sheep.berlios.de>

Log Message:
-----------
Einige Klassen f?r die Interprozesskommunikation ?ber Sockets. CommQSocket ist noch nicht getestet. 
Wird wahrscheinlich nicht compilieren. Aber commsocketserver und commsocketclient haun hin. 
Jetzt m?ssen nur noch die spieler eigene threads werden (HumanPlayer im Hauptprogrammthread und mit
CommQSocket) und die umstellung ist perfekt ;)

Added Files:
-----------
    schafkopf/src:
        commbase.h
        commqsocketclient.cpp
        commqsocketclient.h
        commsocketclient.cpp
        commsocketclient.h
        commsocketserver.cpp
        commsocketserver.h

-------------- next part --------------
--- /dev/null
+++ src/commsocketserver.h
@@ -0,0 +1,129 @@
+/***************************************************************************
+ *   Copyright (C) 2004 by Dominik Seichter                                *
+ *   domseichter at web.de                                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef COMMSOCKETSERVER_H
+#define COMMSOCKETSERVER_H
+
+#include <vector>
+#include <semaphore.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <exception>
+
+#include "commbase.h"
+
+using namespace std;
+
+#define MAX_CONNECTIONS 10
+
+class ESocketError
+    : public exception
+{
+    public:
+        ESocketError()
+            : exception() {}
+        virtual const char *what()
+        {
+            return "Socket error";
+        }
+};
+
+class EConnectError
+    : public ESocketError
+{
+    public:
+        EConnectError()
+            : ESocketError() {}
+        const char *what()
+        {
+            return "Error while connecting";
+        }
+};
+
+class EConnectionClosed
+    : public ESocketError
+{
+    public:
+        EConnectionClosed()
+            : ESocketError() {}
+        const char *what()
+        {
+            return "The connection was closed.";
+        }
+};
+
+class CommSocketServer 
+    : public CommBase
+{
+    public:
+        typedef enum ClientType { player=1, gui, debugger, unregister };
+        struct msgdata
+        {
+            msgtype msg;
+            ClientType type;
+        };
+        struct RegisterMessage
+        {
+            int client;
+            union
+            {
+                msgdata data;
+                char foo[MESSAGE_LENGTH];
+            };
+        };
+
+        CommSocketServer(const char *name, int port, bool global=false);
+        ~CommSocketServer();
+        bool waitMsg(int timeout=-1, int *rec=NULL);
+        bool receiveMsg(Message *msg);
+        bool sendMsg(const Message *msg, bool waitAck=false);
+        int clients(void);
+        ClientType getClientType(int index);
+    
+    private:
+        struct ClientSocket
+        {
+            int socket;
+            ClientType clientType;
+        };
+        struct ServerParams
+        {
+            vector<ClientSocket> clients;
+            sem_t syncSem;
+            sem_t waitSem;
+            pthread_t parent;
+            int serverSocket;
+            unsigned int port;
+            CommSocketServer *self;
+        };
+        
+        ServerParams serverParams;
+        pthread_t threadHandle;
+        
+        bool waitIncoming(int timeout=-1, int *rec=NULL);
+        static bool init_sockaddr(sockaddr_in *name, const char *hostname, unsigned int port);
+        static int create_socket(unsigned int port, bool global);
+        static void serverThread(ServerParams *params);
+};
+
+#endif
--- /dev/null
+++ src/commsocketserver.cpp
@@ -0,0 +1,218 @@
+
+#include <iostream>
+#include <sys/poll.h>
+#include "commsocketserver.h"
+
+CommSocketServer::CommSocketServer(const char *name, int port, bool global)
+    : CommBase(name)
+{
+    pthread_attr_t threadattr;
+
+    serverParams.serverSocket=create_socket(port, global);
+    serverParams.port=port;
+    serverParams.self=this;
+    sem_init(&serverParams.syncSem, 0, 1); 
+    sem_init(&serverParams.waitSem, 0, 0); 
+    serverParams.parent=pthread_self();
+    pthread_create(&threadHandle, NULL, (void *(*)(void *))serverThread, &serverParams);
+    pthread_detach(threadHandle);
+}
+
+CommSocketServer::~CommSocketServer()
+{
+    int i;
+    
+    pthread_kill(threadHandle, SIGTERM);
+    sem_wait(&serverParams.syncSem);
+    for(i=0;i<serverParams.clients.size();i++)
+        close(serverParams.clients[i].socket);
+    sem_post(&serverParams.syncSem);
+    sem_destroy(&serverParams.syncSem);
+    close(serverParams.serverSocket);
+}
+
+bool CommSocketServer::waitMsg(int timeout, int *rec)
+{
+    sem_wait(&serverParams.waitSem);
+    sem_post(&serverParams.waitSem);
+    return waitIncoming(timeout, rec);
+}
+
+bool CommSocketServer::receiveMsg(Message *msg)
+{
+    int n;
+    
+    if(!msg)
+        return false;
+    sem_wait(&serverParams.syncSem);
+    n=read(serverParams.clients[msg->sender].socket, msg->data, MESSAGE_LENGTH);
+    sem_post(&serverParams.syncSem);
+    if(n==0)
+    {
+        sem_wait(&serverParams.syncSem);
+        close(serverParams.clients[msg->sender].socket);
+        serverParams.clients.erase(serverParams.clients.begin()+msg->sender);
+        sem_post(&serverParams.syncSem);
+        sem_wait(&serverParams.waitSem);
+        throw EConnectionClosed();
+    }
+    else if(n!=MESSAGE_LENGTH)
+        return false;
+    return true;
+}
+
+bool CommSocketServer::sendMsg(const Message *msg, bool waitAck)
+{
+    int n;
+    Message m;
+    Message ack;
+    
+    if(!msg)
+        return false;
+    memcpy(&m, msg, sizeof(CommBase::Message));
+    if(waitAck)
+        m.msg = (CommBase::msgtype)((int)CommBase::msg_ack | (int)m.msg); 
+    sem_wait(&serverParams.syncSem);
+    n=write(serverParams.clients[m.receiver].socket, m.data, MESSAGE_LENGTH);
+    sem_post(&serverParams.syncSem);
+    if(n==0)
+    {
+        sem_wait(&serverParams.syncSem);
+        close(serverParams.clients[m.sender].socket);
+        serverParams.clients.erase(serverParams.clients.begin()+m.sender);
+        sem_post(&serverParams.syncSem);
+        throw EConnectionClosed();
+    }
+    else if(n!=MESSAGE_LENGTH)
+        return false;
+    if(waitAck)
+    {
+        for(;;)
+        {
+            ack.sender=m.receiver;
+            if(!receiveMsg(&ack))
+                return false;
+            if(!(ack.msg & CommBase::msg_ack))
+                continue;
+            break;
+        }
+    }
+    return true;
+}
+
+int CommSocketServer::clients(void)
+{
+    return serverParams.clients.size();
+}
+
+CommSocketServer::ClientType CommSocketServer::getClientType(int index)
+{
+    return serverParams.clients[index].clientType;
+}
+
+bool CommSocketServer::waitIncoming(int timeout, int *rec)
+{
+    int i, n;
+    pollfd *fds;
+
+    sem_wait(&serverParams.syncSem);
+    fds=new pollfd[serverParams.clients.size()];
+    for(i=0;i<serverParams.clients.size();i++)
+    {
+        fds[i].fd=serverParams.clients[i].socket;
+        fds[i].events=POLLIN | POLLHUP | POLLNVAL | POLLERR;
+        fds[i].revents=0;
+    }
+    n=poll(fds, serverParams.clients.size(), timeout);
+    sem_post(&serverParams.syncSem);
+    if(!rec)
+    {
+        delete fds;
+        return n ? true : false;
+    }
+    if(!n)
+    {
+        delete fds;
+        return false;
+    }
+    sem_wait(&serverParams.syncSem);
+    for(i=0;i<serverParams.clients.size();i++)
+        if(fds[i].revents)
+            break;
+    sem_post(&serverParams.syncSem);
+    *rec=i;
+    delete fds;
+    return true;
+}
+
+bool CommSocketServer::init_sockaddr(sockaddr_in *name, const char *hostname, unsigned int port)
+{
+    hostent *hostinfo;
+
+    name->sin_family = AF_INET;
+    name->sin_port = htons (port);
+    hostinfo = gethostbyname (hostname);
+    if (hostinfo == NULL)
+        return false;
+    name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
+    return true;
+}
+
+int CommSocketServer::create_socket(unsigned int port, bool global)
+{
+    int sock;
+    sockaddr_in addr;
+    int set=1;
+    
+    sock=socket (global ? PF_INET : PF_LOCAL, SOCK_STREAM, 0);
+    if(sock<0)
+        return -1;
+    if(!init_sockaddr(&addr, "localhost", port))
+    {
+        close(sock);
+        return -1;
+    }
+    if(bind(sock, (sockaddr *)&addr, sizeof(sockaddr_in))<0)
+    {
+        close(sock);
+        return -1;
+    }
+    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &set, sizeof(int));
+    return sock;
+}
+
+void CommSocketServer::serverThread(ServerParams *params)
+{
+    fd_set fds;
+    ClientSocket client;
+    RegisterMessage msg;
+    int i;
+    char ch;
+    
+    for(;;)
+    {
+        FD_SET(params->serverSocket , &fds);
+        select(params->serverSocket+1, &fds, &fds, &fds, NULL);
+        if(listen(params->serverSocket, MAX_CONNECTIONS)<0)
+            continue;
+        client.socket=accept(params->serverSocket, NULL, NULL);
+        sem_wait(&params->syncSem);
+        params->clients.push_back(client);
+        msg.client=params->clients.size()-1;
+        sem_post(&params->syncSem);
+        params->self->waitIncoming();
+        if(!params->self->receiveMsg((CommBase::Message *)&msg))
+        {
+            sem_wait(&params->syncSem);
+            close(params->clients[msg.client].socket);
+            params->clients.pop_back();
+            sem_post(&params->syncSem);
+            continue;
+        }
+        sem_wait(&params->syncSem);
+        params->clients[msg.client].clientType=msg.data.type;
+        sem_post(&params->syncSem);
+        sem_post(&params->waitSem);
+    }
+}
+
--- /dev/null
+++ src/commsocketclient.h
@@ -0,0 +1,45 @@
+/***************************************************************************
+ *   Copyright (C) 2004 by Dominik Seichter                                *
+ *   domseichter at web.de                                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef COMMSOCKETCLIENT_H
+#define COMMSOCKETCLIENT_H 
+
+#include "commbase.h"
+#include "commsocketserver.h"
+
+class CommSocketClient 
+    : public CommBase
+{
+    public:
+        CommSocketClient(const char *hostname, unsigned int port, bool local, CommSocketServer::ClientType type); 
+        ~CommSocketClient(); 
+        bool waitMsg(int timeout=-1, int *rec=NULL); 
+        bool receiveMsg(Message *msg);
+        bool sendMsg(const Message *msg, bool waitAck=false);
+        
+    private:
+        int clientSocket;
+        
+        static int init_sockaddr (sockaddr_in *name, const char *hostname, unsigned int port);
+        static int open_socket(const char *hostname, unsigned int port, bool local);
+};
+
+#endif
+
--- /dev/null
+++ src/commsocketclient.cpp
@@ -0,0 +1,132 @@
+#include <iostream>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include "commsocketclient.h"
+#include "commsocketserver.h"
+
+CommSocketClient::CommSocketClient(const char *hostname, unsigned int port, bool local, CommSocketServer::ClientType type)
+    : CommBase(hostname)
+{
+    CommSocketServer::RegisterMessage msg;
+    
+    clientSocket=open_socket(hostname, port, local);
+    if(clientSocket<0)
+        throw EConnectError();
+    msg.data.msg=CommBase::msg_msg;
+    msg.data.type=type;
+    sendMsg((CommBase::Message *)&msg, false);
+}
+
+CommSocketClient::~CommSocketClient()
+{
+    close(clientSocket);
+}
+
+bool CommSocketClient::waitMsg(int timeout, int *rec)
+{
+    int i, n;
+    pollfd fds;
+
+    fds.fd=clientSocket;
+    fds.events=POLLIN | POLLHUP | POLLNVAL | POLLERR;
+    fds.revents=0;
+    n=poll(&fds, 1, timeout);
+    if(!n)
+        return false;
+    if(fds.revents & (POLLHUP | POLLNVAL | POLLERR))
+        throw ESocketError();
+    return true;
+}
+
+bool CommSocketClient::receiveMsg(Message *msg)
+{
+    int n;
+    
+    if(!msg)
+        return false;
+    n=read(clientSocket, msg->data, MESSAGE_LENGTH);
+    if(n==0)
+    {
+        close(clientSocket);
+        throw EConnectionClosed();
+    }
+    if(n!=MESSAGE_LENGTH)
+        return false;
+    return true;
+}
+
+bool CommSocketClient::sendMsg(const Message *msg, bool waitAck)
+{
+    int n;
+    Message ack;
+    Message m;
+    
+    if(!msg)
+        return false;
+    memcpy(&m, msg, sizeof(Message));
+    if(waitAck)
+        m.msg = (CommBase::msgtype) ((int)CommBase::msg_ack | (int)m.msg); 
+    n=write(clientSocket, m.data, MESSAGE_LENGTH);
+    if(n==0)
+    {
+        close(clientSocket);
+        throw EConnectionClosed();
+    }
+    if(n!=MESSAGE_LENGTH)
+        return false;
+    if(waitAck)
+    {
+        for(;;)
+        {
+            ack.sender=m.receiver;
+            if(!receiveMsg(&ack))
+                return false;
+            if(!(ack.msg & CommBase::msg_ack))
+                continue;
+            break;
+        }
+    }
+    return true;
+}
+
+int CommSocketClient::init_sockaddr (sockaddr_in *name, const char *hostname, unsigned int port)
+{
+    struct hostent *hostinfo;
+
+    name->sin_family = AF_INET;
+    name->sin_port = htons (port);
+    hostinfo = gethostbyname (hostname);
+    if (hostinfo == NULL)
+    {
+        printf("Unbekanter host %s.\n", hostname);
+        return 0;
+    }
+    name->sin_addr = *(struct in_addr *) hostinfo->h_addr;
+    return 1;
+}
+
+int CommSocketClient::open_socket(const char *hostname, unsigned int port, bool local)
+{
+    int sock;
+    sockaddr_in addr;
+    
+    sock=socket(PF_INET, SOCK_STREAM, 0);
+    if(sock<0)
+    {
+        return -1;
+    }
+    if(!init_sockaddr(&addr, hostname, port))
+    {
+        close(sock);
+        return -1;
+    }
+    if(connect(sock, (sockaddr *)&addr, sizeof(sockaddr_in))<0)
+    {
+        close(sock);
+        return -1;
+    }
+    return sock;
+}
+
--- /dev/null
+++ src/commbase.h
@@ -0,0 +1,83 @@
+/***************************************************************************
+ *   Copyright (C) 2004 by Dominik Seichter                                *
+ *   domseichter at web.de                                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef COMMBASE_H
+#define COMMBASE_H
+
+#include <string>
+
+using namespace std;
+
+#define MESSAGE_LENGTH 128
+
+class CommBase
+{
+    public:
+        typedef enum msgtype   { msg_broadcast = 0, 
+                                 msg_ack = 1 << 1,
+                                 msg_ackbroadcast= CommBase::msg_broadcast | CommBase::msg_ack,
+                                 msg_msg = 1, 
+                                 msg_ackmsg = CommBase::msg_msg | CommBase::msg_ack,
+                                 msg_exit = 1 << 2 };
+        struct Message
+        {
+            union
+            {
+                int receiver;
+                int sender;
+            };
+            union
+            {
+                CommBase::msgtype msg;
+                char data[MESSAGE_LENGTH];
+            };
+        };
+        
+        CommBase(const char *name) { this->name=name; }
+        virtual ~CommBase() {}
+        /// Waits for an incoming message. 
+        /**
+         * \param timeout Time to wait for an incoming message. -1 for no timeout. 0 only checks if a message is available. 
+         * \param *rec Contains a pointer to an int for the client who sent
+         * a message
+         * \return true if a message is waiting or false for no message.
+         */
+        virtual bool waitMsg(int timeout=-1, int *rec=NULL) = 0;
+        
+        /// Receives a message
+        /**
+         * \param *msg Pointer to CommBase::Message-struct for the received Message.
+         * \return true if a message was received. 
+         */
+        virtual bool receiveMsg(Message *msg) = 0;
+
+        /// Sends a message. 
+        /**
+         * \param *msg Pointer to the message to be sent. 
+         * \return true if the message was sent. 
+         */
+        virtual bool sendMsg(const Message *msg, bool waitAck=false) = 0;
+        
+    protected:
+        string name;
+};
+
+#endif
+
--- /dev/null
+++ src/commqsocketclient.cpp
@@ -0,0 +1,74 @@
+
+#include "commqsocketclient.h"
+#include "commsocketserver.h"
+
+CommQSocketClient::CommQSocketClient(const char *hostname, unsigned int port, CommSocketServer::ClientType type)
+    : CommBase(hostname), QObject()
+{
+    CommSocketServer::RegisterMessage msg;
+    
+    clientSocket.connectToHost(hostname, port);
+    if(!clientSocket.connected())
+        throw EConnectError();
+    msg.data.msg=CommBase::msg_msg;
+    msg.data.type=type;
+    sendMsg(&msg, false);
+    connect(this, SIGNAL(readyRead()), this, SLOT(dataWaiting()));
+}
+
+CommQSocketClient::~CommQSocketClient()
+{
+}
+
+bool CommQSocketClient::waitMsg(int timeout, int *rec)
+{
+    if(clientSocket.waitForMore(timeout))
+        return true;
+    return false;
+}
+
+bool CommQSocketClient::receiveMsg(Message *msg)
+{
+    int n;
+    
+    if(!msg)
+        return false;
+    if(!clientSocket.connected())
+        throw EConnectionClosed();
+    n=clientSocket.readBlock(msg->data, MESSAGE_LENGTH);
+    if(n!=MESSAGE_LENGTH)
+        return false;
+    return true;
+}
+
+bool CommQSocketClient::sendMsg(const Message *msg, bool waitAck)
+{
+    int n;
+    Message ack;
+    Message m;
+    
+    if(!msg)
+        return false;
+    memcpy(&m, msg, sizeof(CommBase::Message));
+    if(waitAck)
+        m.msg |= CommBase::msg_ack; 
+    if(!clientSocket.connected())
+        throw EConnectionClosed();
+    n=writeBlock(m.data, MESSAGE_LENGTH);
+    if(n!=MESSAGE_LENGTH)
+        return false;
+    if(waitAck)
+    {
+        for(;;)
+        {
+            ack.sender=m.receiver;
+            if(!receiveMsg(&ack))
+                return false;
+            if(!(ack.msg & CommBase::msg_ack))
+                continue;
+            break;
+        }
+    }
+    return true;
+}
+
--- /dev/null
+++ src/commqsocketclient.h
@@ -0,0 +1,51 @@
+/***************************************************************************
+ *   Copyright (C) 2004 by Dominik Seichter                                *
+ *   domseichter at web.de                                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef COMMQSOCKETCLIENT_H
+#define COMMQSOCKETCLIENT_H 
+
+#include <qobject.h>
+#include <qsocket.h>
+
+#include "commbase.h"
+
+using namespace std;
+
+class CommQSocketClient 
+    : public CommBase, public QObject
+{
+    public:
+        CommQSocketClient(const char *hostname, unsigned int port, CommSocketServer::ClientType type);
+        ~CommQSocketServer();
+        bool waitMsg(int timeout=-1, int *rec=NULL); 
+        bool receiveMsg(Message *msg);
+        bool sendMsg(Message *msg, bool waitAck=false);
+        
+    protected:
+        QSocket clientSocket;
+        
+        virtual void msgReceived() = 0;
+
+    private slots:
+        void dataWaiting();
+};
+
+#endif
+

From schafkopf-devel at berlios.de  Tue Feb 15 19:47:47 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Tue, 15 Feb 2005 19:47:47 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf lokale sockets funzen jetz auch
Message-ID: <200502151847.j1FIllCQ017357@sheep.berlios.de>

Log Message:
-----------
lokale sockets funzen jetz auch

Modified Files:
--------------
    schafkopf/src:
        commsocketclient.cpp
        commsocketclient.h
        commsocketserver.cpp

-------------- next part --------------
Index: commsocketserver.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/commsocketserver.cpp,v
retrieving revision 1.1
retrieving revision 1.2
diff -Lsrc/commsocketserver.cpp -Lsrc/commsocketserver.cpp -u -r1.1 -r1.2
--- src/commsocketserver.cpp
+++ src/commsocketserver.cpp
@@ -1,6 +1,8 @@
 
 #include <iostream>
 #include <sys/poll.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 #include "commsocketserver.h"
 
 CommSocketServer::CommSocketServer(const char *name, int port, bool global)
@@ -161,18 +163,28 @@
 int CommSocketServer::create_socket(unsigned int port, bool global)
 {
     int sock;
-    sockaddr_in addr;
+    sockaddr_in gaddr;
+    sockaddr_un laddr;
+    sockaddr *addr=(sockaddr *)&gaddr;
+    int n=sizeof(sockaddr_in);
     int set=1;
     
-    sock=socket (global ? PF_INET : PF_LOCAL, SOCK_STREAM, 0);
+    sock=socket(global ? PF_INET : PF_LOCAL, SOCK_STREAM, 0);
     if(sock<0)
         return -1;
-    if(!init_sockaddr(&addr, "localhost", port))
+    if(!global)
+    {
+        laddr.sun_family=AF_LOCAL;
+        sprintf(laddr.sun_path, "%d", port);
+        addr=(sockaddr *) &laddr;
+        n=SUN_LEN(&laddr);
+    }
+    else if(!init_sockaddr(&gaddr, "localhost", port))
     {
         close(sock);
         return -1;
     }
-    if(bind(sock, (sockaddr *)&addr, sizeof(sockaddr_in))<0)
+    if(bind(sock, addr, n)<0)
     {
         close(sock);
         return -1;
Index: commsocketclient.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/commsocketclient.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -Lsrc/commsocketclient.h -Lsrc/commsocketclient.h -u -r1.1 -r1.2
--- src/commsocketclient.h
+++ src/commsocketclient.h
@@ -28,7 +28,7 @@
     : public CommBase
 {
     public:
-        CommSocketClient(const char *hostname, unsigned int port, bool local, CommSocketServer::ClientType type); 
+        CommSocketClient(const char *hostname, unsigned int port, bool global, CommSocketServer::ClientType type); 
         ~CommSocketClient(); 
         bool waitMsg(int timeout=-1, int *rec=NULL); 
         bool receiveMsg(Message *msg);
@@ -38,7 +38,7 @@
         int clientSocket;
         
         static int init_sockaddr (sockaddr_in *name, const char *hostname, unsigned int port);
-        static int open_socket(const char *hostname, unsigned int port, bool local);
+        static int open_socket(const char *hostname, unsigned int port, bool global);
 };
 
 #endif
Index: commsocketclient.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/commsocketclient.cpp,v
retrieving revision 1.1
retrieving revision 1.2
diff -Lsrc/commsocketclient.cpp -Lsrc/commsocketclient.cpp -u -r1.1 -r1.2
--- src/commsocketclient.cpp
+++ src/commsocketclient.cpp
@@ -1,17 +1,18 @@
 #include <iostream>
 #include <sys/socket.h>
+#include <sys/un.h>
 #include <sys/poll.h>
 #include <netinet/in.h>
 #include <netdb.h>
 #include "commsocketclient.h"
 #include "commsocketserver.h"
 
-CommSocketClient::CommSocketClient(const char *hostname, unsigned int port, bool local, CommSocketServer::ClientType type)
+CommSocketClient::CommSocketClient(const char *hostname, unsigned int port, bool global, CommSocketServer::ClientType type)
     : CommBase(hostname)
 {
     CommSocketServer::RegisterMessage msg;
     
-    clientSocket=open_socket(hostname, port, local);
+    clientSocket=open_socket(hostname, port, global);
     if(clientSocket<0)
         throw EConnectError();
     msg.data.msg=CommBase::msg_msg;
@@ -107,24 +108,34 @@
     return 1;
 }
 
-int CommSocketClient::open_socket(const char *hostname, unsigned int port, bool local)
+int CommSocketClient::open_socket(const char *hostname, unsigned int port, bool global)
 {
     int sock;
-    sockaddr_in addr;
+    sockaddr_in gaddr;
+    sockaddr_un laddr;
+    sockaddr *addr=(sockaddr *)&gaddr;
+    int n=sizeof(sockaddr_in);
+    int set=1;
     
-    sock=socket(PF_INET, SOCK_STREAM, 0);
+    sock=socket(global ? PF_INET : PF_LOCAL, SOCK_STREAM, 0);
     if(sock<0)
-    {
         return -1;
+    if(!global)
+    {
+        laddr.sun_family=AF_LOCAL;
+        sprintf(laddr.sun_path, "%d", port);
+        addr=(sockaddr *) &laddr;
+        n=SUN_LEN(&laddr);
     }
-    if(!init_sockaddr(&addr, hostname, port))
+    else if(!init_sockaddr(&gaddr, "localhost", port))
     {
         close(sock);
         return -1;
     }
-    if(connect(sock, (sockaddr *)&addr, sizeof(sockaddr_in))<0)
+    if(connect(sock, addr, n)<0)
     {
         close(sock);
+        cerr << "connect failed" << endl;
         return -1;
     }
     return sock;

From schafkopf-devel at berlios.de  Fri Feb 18 18:53:43 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Fri, 18 Feb 2005 18:53:43 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf aktuelle TODO-Liste jetzt auch auf der
Message-ID: <200502181753.j1IHrhm6015281@sheep.berlios.de>

Log Message:
-----------
aktuelle TODO-Liste jetzt auch auf der Homepage

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.9
retrieving revision 1.10
diff -LTODO -LTODO -u -r1.9 -r1.10
--- TODO
+++ TODO
@@ -1,3 +1,5 @@
+<b>18.02.2005</b>
+
 Fixen:
 - Rufsau nach davonlaufen in allowedCards hinzuf?gen
 

From schafkopf-devel at berlios.de  Fri Feb 18 18:57:21 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Fri, 18 Feb 2005 18:57:21 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Mist.
Message-ID: <200502181757.j1IHvLMa022598@sheep.berlios.de>

Log Message:
-----------
Mist. HTML-Tags gehen nicht

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.10
retrieving revision 1.11
diff -LTODO -LTODO -u -r1.10 -r1.11
--- TODO
+++ TODO
@@ -1,4 +1,4 @@
-<b>18.02.2005</b>
+18.02.2005
 
 Fixen:
 - Rufsau nach davonlaufen in allowedCards hinzuf?gen

From michael.hoechstetter at gmx.de  Fri Feb 18 19:47:24 2005
From: michael.hoechstetter at gmx.de (Michael =?iso-8859-15?q?H=F6chstetter?=)
Date: Fri, 18 Feb 2005 19:47:24 +0100
Subject: [Schafkopf-devel] Fehler im Computerspiel / Todoliste
Message-ID: <200502181947.30041.michael.hoechstetter@gmx.de>

Servus

Im Modus "Eichel Ober mu? spielen" d?rfte ein Fehler im Code sein, denn bis 
jetzt (5 mal zusammengeworfen). Hat der Spieler, der den Alten hatte, immer 
ein Eichel-Sticht gespielt. Sollte vielleicht auf die TODO-Liste.

Bis bald,
Michi
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/schafkopf-devel/attachments/20050218/940e977d/attachment.pgp>

From domseichter at web.de  Fri Feb 18 19:55:20 2005
From: domseichter at web.de (Dominik Seichter)
Date: Fri, 18 Feb 2005 19:55:20 +0100
Subject: [Schafkopf-devel] Fehler im Computerspiel / Todoliste
In-Reply-To: <200502181947.30041.michael.hoechstetter@gmx.de>
References: <200502181947.30041.michael.hoechstetter@gmx.de>
Message-ID: <200502181955.20850.domseichter@web.de>

Am Friday, 18. February 2005 19:47 schrieb Michael H?chstetter:
> Servus
>
> Im Modus "Eichel Ober mu? spielen" d?rfte ein Fehler im Code sein, denn bis
> jetzt (5 mal zusammengeworfen). Hat der Spieler, der den Alten hatte, immer
> ein Eichel-Sticht gespielt. Sollte vielleicht auf die TODO-Liste.
Das ist im Moment denke ich sogar Hardgecodet. Das Problem an der Sache ist im 
Moment der schlechte Code der Benutzt wird um zu entscheiden was und ob der 
Computer spielen will.
Wenn der Computer gefragt wird ob er spielen will versucht er Spiele zu finden 
die M?glich sind und die er spielen kann. Findet er keines will er nicht 
spielen. Wenn allerdings kein anderer spielen will und der Computer den Alten 
hat muss er pl?tzlich spielen. Er hat jedoch vorher kein spielbares Spiel 
gefunden und daher gibt es den hardgecodeten Fallback "Eichelsticht".

Also es ist nicht umbedingt ein Fehler im Code, das Problem ist der Code 
ansich :). Nat?rlich sollte es auf die TODO Liste. W?re auch eine gute 
Gelegenheit den Code zu verbessern wie entschieden wird was gespielt werden 
soll.

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From schafkopf-devel at berlios.de  Fri Feb 18 20:52:44 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Fri, 18 Feb 2005 20:52:44 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf TODO upgedated
Message-ID: <200502181952.j1IJqiRh015851@sheep.berlios.de>

Log Message:
-----------
TODO upgedated

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.11
retrieving revision 1.12
diff -LTODO -LTODO -u -r1.11 -r1.12
--- TODO
+++ TODO
@@ -1,5 +1,5 @@
-18.02.2005
-
+<b>18.02.2005</b>
+<pre>
 Fixen:
 - Rufsau nach davonlaufen in allowedCards hinzuf?gen
 
@@ -10,6 +10,7 @@
 - ?fters Rufspiele spielen
 - "Wird eine Farbe das zweite Mal gespielt, so sollte ein AI-Spieler mindestens mit einem Unter stechen, sofern hinter ihm noch ein Gegner kommt." (auf keinen Fall schmieren!!)
 - "Als Spieler nicht die Sau suchen, sondern Trumpf ausspielen"
+- Computer waehlt kein Spiel aus, sondern spielt Eichel-Sticht, wenn er spielen muss (aber nicht will).
 
 neue Features:
 - Tastatursteuerung
@@ -20,3 +21,4 @@
 - Trainingsmodus mit "R?ckg?ngig"-Funktion (auch mehrere Stiche)
 - "Letzter Stich"-Dialog: Karten so anordnen wie auf dem Spielfeld
 - Kontra, Reh, ...
+</pre>
\ No newline at end of file

From schafkopf-devel at berlios.de  Sat Feb 19 15:39:38 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sat, 19 Feb 2005 15:39:38 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf (butt-ugly) Tastatursteuerung  Das spielen ist
Message-ID: <200502191439.j1JEdc3T012991@sheep.berlios.de>

Log Message:
-----------
(butt-ugly) Tastatursteuerung

Das spielen ist jetzt sch?n konfortabel wenn man ned dauernd rum klicken muss!

Rechts/Links verschieben den Focus und Return/Enter "klickt" das aktuell gew?hlte Element an. Zuvor muss man nat?rlich den Spielfeld den Tastatur Focus geben. Habe ?berlegt ob ich TAB und Shift-TAB zum wechseln nehmen soll, aber die Pfeiltasten gefall mir besser.

Die schillernden Farben k?nnt ihr nat?rlich gerne gegen sch?nere austauschen. Als Informatiker sollte ich mich bei geschmacksfragen eh raushalten.

Modified Files:
--------------
    schafkopf:
        TODO
    schafkopf/src:
        canvascard.cpp
        canvascard.h
        canvasplayer.cpp
        canvasplayer.h
        computerplayer.cpp
        computerplayer.h
        game.cpp
        game.h
        gamecanvas.cpp
        gamecanvas.h
        humanplayer.cpp
        humanplayer.h
        player.cpp
        player.h
        schafkopfdef.h

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.12
retrieving revision 1.13
diff -LTODO -LTODO -u -r1.12 -r1.13
--- TODO
+++ TODO
@@ -1,24 +1,23 @@
 <b>18.02.2005</b>
 <pre>
 Fixen:
-- Rufsau nach davonlaufen in allowedCards hinzuf?gen
+- Rufsau nach davonlaufen in allowedCards hinzufgen
 
 AI:
 - Solo: Mitspieler schmieren dem Spieler
-- Solo: Spieler spielt seine Tr?mpfe zu sp?t.
-- Computer schmiert auch Ober wenn er nix h?heres hat
-- ?fters Rufspiele spielen
+- Solo: Spieler spielt seine Trmpfe zu sp???.
+- Computer schmiert auch Ober wenn er nix h???eres hat
+- ???ters Rufspiele spielen
 - "Wird eine Farbe das zweite Mal gespielt, so sollte ein AI-Spieler mindestens mit einem Unter stechen, sofern hinter ihm noch ein Gegner kommt." (auf keinen Fall schmieren!!)
 - "Als Spieler nicht die Sau suchen, sondern Trumpf ausspielen"
 - Computer waehlt kein Spiel aus, sondern spielt Eichel-Sticht, wenn er spielen muss (aber nicht will).
 
 neue Features:
-- Tastatursteuerung
-- "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realit?t kann ich es davon abh?ngig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralit?t stattfindet." Und dann nur Spiele ausw?hlbar machen die h?her sind als die vorher angesagten.
-- richtige Schafkopfkarten hinzuf?gen
-- netzwerktransparente Kommunikation (f?r neuronales Netzwerk und Netzwerkspiel)
+- "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realit??? kann ich es davon abh???gig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralit??? stattfindet." Und dann nur Spiele ausw???lbar machen die h???er sind als die vorher angesagten.
+- richtige Schafkopfkarten hinzufgen
+- netzwerktransparente Kommunikation (fr neuronales Netzwerk und Netzwerkspiel)
 - speichern und laden von Spielen
-- Trainingsmodus mit "R?ckg?ngig"-Funktion (auch mehrere Stiche)
+- Trainingsmodus mit "Rckg???gig"-Funktion (auch mehrere Stiche)
 - "Letzter Stich"-Dialog: Karten so anordnen wie auf dem Spielfeld
 - Kontra, Reh, ...
 </pre>
Index: canvascard.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.cpp,v
retrieving revision 1.17
retrieving revision 1.18
diff -Lsrc/canvascard.cpp -Lsrc/canvascard.cpp -u -r1.17 -r1.18
--- src/canvascard.cpp
+++ src/canvascard.cpp
@@ -66,17 +66,25 @@
         KPixmap pix = pixmap->xForm( wm );
         if( m_forbidden )
             pix = KPixmapEffect::fade( pix, 0.5, Qt::gray );
-        
+        else if( isActive() )
+            pix = KPixmapEffect::fade( pix, 0.25, Qt::yellow );
+            
         setSize( pix.width()+3, pix.height()+3 );
         bitBlt( p.device(), point.x(), point.y(), &pix );
         if(loadOK1 && loadOK2)
         {
-	if( m_rotation==0 || m_rotation==180)
-            bitBlt( p.device(), point.x(), point.y(), &Shadow );
-        else
-            bitBlt( p.device(), point.x(), point.y(), &Shadow2 );
+            if( m_rotation==0 || m_rotation==180)
+                bitBlt( p.device(), point.x(), point.y(), &Shadow );
+            else
+                bitBlt( p.device(), point.x(), point.y(), &Shadow2 );
         }
     }
+}
+
+void CanvasCard::setActive( bool b )
+{
+    QCanvasItem::update();
+    QCanvasItem::setActive( b );
 }
 
 void CanvasCard::setFrontVisible( bool b )
Index: schafkopfdef.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopfdef.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -Lsrc/schafkopfdef.h -Lsrc/schafkopfdef.h -u -r1.7 -r1.8
--- src/schafkopfdef.h
+++ src/schafkopfdef.h
@@ -53,11 +53,28 @@
     void* returncode;
     int* cardids;
 
+    
     bool wait;
     bool quitgame;
     
     QStringList* playernames;
     QString data;
+};
+
+typedef struct t_PlayerData {
+    unsigned int id1;
+    int* cards1;
+    
+    unsigned int id2;
+    int* cards2;
+
+    unsigned int id3;
+    int* cards3;
+
+    unsigned int id4;
+    int* cards4;
+
+    unsigned int lastid;
 };
 
 /** Uncomment this line to make all cards
Index: player.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/player.cpp,v
retrieving revision 1.29
retrieving revision 1.30
diff -Lsrc/player.cpp -Lsrc/player.cpp -u -r1.29 -r1.30
--- src/player.cpp
+++ src/player.cpp
@@ -8,14 +8,12 @@
 #include <cstdlib>
 using namespace std;
 
-unsigned int Player::def_id=0;
-
-Player::Player(Game* game)
+Player::Player(unsigned int id, Game* game)
     : m_game( game )
 {
     m_stiche = new CardList();
     m_points = 0.0;
-    m_id=def_id++;
+    m_id=id;
     m_cards = NULL;
     
     m_has_doubled = false;
Index: humanplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/humanplayer.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/humanplayer.h -Lsrc/humanplayer.h -u -r1.13 -r1.14
--- src/humanplayer.h
+++ src/humanplayer.h
@@ -25,7 +25,7 @@
 class HumanPlayer : public Player
 {
     public:
-        HumanPlayer(Game* game);
+        HumanPlayer(unsigned int id, Game* game);
         ~HumanPlayer();
         
         void klopfen();
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.43
retrieving revision 1.44
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.43 -r1.44
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -32,6 +32,22 @@
 #include <qtimer.h>
 #include <qimage.h>
 
+class CanvasText : public QCanvasText {
+    public:
+        CanvasText( const QString & t, const QFont & f, QCanvas* c )
+            : QCanvasText( t, f, c )
+        {
+            setActive( false );
+        }
+        
+        void setActive( bool b )
+        {
+            setColor( b ? Qt::white : Qt::yellow );
+            QCanvasText::setActive( b );
+        }
+
+};
+
 GameCanvas::GameCanvas(QCanvas* c, QWidget *parent, const char *name)
  : QCanvasView(c,parent, name)
 {
@@ -46,15 +62,11 @@
         
     QFont f( "Helvetica", 24 );
     
-    m_message = new QCanvasText( QString::null, f, canvas() );;
-    m_yes = new QCanvasText( i18n("Yes"), f, canvas() );;
-    m_no = new QCanvasText( i18n("No"), f, canvas() );;
-    m_ok = new QCanvasText( i18n("OK"), f, canvas() );
-    
-    m_message->setColor( Qt::yellow );
-    m_yes->setColor( Qt::yellow );
-    m_no->setColor( Qt::yellow );
-    m_ok->setColor( Qt::yellow );
+    m_message = new CanvasText( QString::null, f, canvas() );;
+    m_yes = new CanvasText( i18n("Yes"), f, canvas() );;
+    m_no = new CanvasText( i18n("No"), f, canvas() );;
+    m_ok = new CanvasText( i18n("OK"), f, canvas() );
+    
     
     // Does not work :-(
     /*
@@ -65,6 +77,7 @@
     */
     
     m_result = 0;
+    setFocusPolicy( QWidget::StrongFocus );
     
     canvas()->setBackgroundColor( Qt::darkGreen );
     
@@ -74,6 +87,13 @@
     
     connect( Settings::instance(), SIGNAL(cardChanged()), this, SLOT(positionObjects()));
     connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(yesNoClicked(QCanvasItem*)));
+    
+    m_focus_list.append( m_yes );
+    m_focus_list.append( m_no );
+    m_focus_list.append( m_ok );
+    for( i=0;i<NUMCARDS;i++ )
+        m_focus_list.append( m_players[0]->canvasCard( i ) );
+    
 }    
 
 GameCanvas::~GameCanvas()
@@ -192,8 +212,24 @@
 
 int GameCanvas::getCard()
 {
+    CanvasPlayer* human = humanPlayer();
+    CanvasCard* c = NULL;
+    unsigned int i;
+    
     connect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(cardClicked(QCanvasItem*)));
     m_result = -1;
+
+    if( hasFocus() )
+        for( i=0;i<NUMCARDS;i++)
+        {
+            c = human->canvasCard( i );
+            if( c )
+            {
+                c->setActive( true );
+                break;
+            }
+        }
+    
     ENTER_LOOP();
     
     return m_result;
@@ -201,6 +237,9 @@
 
 void GameCanvas::cardClicked( QCanvasItem* item )
 {
+    if( item )
+        item->setActive( false );
+        
     if( item->rtti() == CANVASCARD ) 
     {
         CanvasCard* card = static_cast<CanvasCard*>(item);
@@ -339,6 +378,82 @@
     }
 }
 
+void GameCanvas::keyPressEvent(QKeyEvent* e)
+{
+    unsigned int i = 0;
+    int z = 0;
+    
+    if( e->key() == Qt::Key_Enter || e->key() == Qt::Key_Return )
+    {
+        for( i=0;i<m_focus_list.count();i++ )
+            if( m_focus_list[i]->isActive() )
+            {
+                if( m_focus_list[i]->rtti() == QCanvasItem::Rtti_Text )                
+                    yesNoClicked( m_focus_list[i] );
+                else if( m_focus_list[i]->rtti() == CANVASCARD )
+                    cardClicked( m_focus_list[i] );
+            }
+    }
+    else if( e->key() == Qt::Key_Right )
+    {
+        for( i=0;i<m_focus_list.count();i++ )
+            if( m_focus_list[i]->isActive() )
+            {
+                for( z=i+1;z<m_focus_list.count();z++ )
+                    if( m_focus_list[z]->isVisible() )
+                    {
+                        if( m_message->isVisible() && m_focus_list[z]->rtti() == CANVASCARD )
+                            continue;
+                            
+                        m_focus_list[i]->setActive( false );
+                        m_focus_list[z]->setActive( true );
+                        break;
+                    }
+                break;
+            }
+    }
+    else if( e->key() == Qt::Key_Left )
+    {
+        for( i=0;i<m_focus_list.count();i++ )
+            if( m_focus_list[i]->isActive() )
+            {
+                for( z=i-1;z>=0;z-- )
+                    if( m_focus_list[z]->isVisible() )
+                    {
+                        if( m_message->isVisible() && m_focus_list[z]->rtti() == CANVASCARD )
+                            continue;
+
+                        m_focus_list[i]->setActive( false );
+                        m_focus_list[z]->setActive( true );
+                        break;
+                    }
+                break;
+            }
+    }
+}
+
+void GameCanvas::focusInEvent(QFocusEvent*)
+{
+    int i;
+    for(i=0;i<m_focus_list.count();i++)
+        if( m_focus_list[i]->isVisible() )
+        {
+            m_focus_list[i]->setActive( true );
+            break;
+        }
+}
+
+void GameCanvas::focusOutEvent(QFocusEvent*)
+{
+    int i;
+    for(i=0;i<m_focus_list.count();i++)
+        if( m_focus_list[i]->isActive() )
+        {
+            m_focus_list[i]->setActive( false );
+            break;
+        }
+}
+
 bool GameCanvas::questionYesNo( const QString & message )
 {
     m_result = NO;
@@ -351,6 +466,8 @@
     positionObjects();
     
     canvas()->update();
+    if( hasFocus() )
+        m_yes->setActive( true );
     ENTER_LOOP();
     
     m_message->hide();
@@ -364,6 +481,9 @@
 
 void GameCanvas::yesNoClicked( QCanvasItem* item )
 {
+    if( item )
+        item->setActive( false );
+        
     if( m_message && ((m_yes && m_no) || m_ok ))
     {
         if( item == m_yes )
@@ -393,6 +513,8 @@
     positionObjects();
     
     canvas()->update();
+    if( hasFocus() )
+        m_ok->setActive( true );
     ENTER_LOOP();
 
     m_message->hide();
@@ -463,6 +585,15 @@
     for(i=0;i<PLAYERS;i++)
         if( m_players[i]->id() == id )
             m_players[i]->setCards( &list );
+}
+
+CanvasPlayer* GameCanvas::humanPlayer() const
+{
+    int i;
+    for( i = 0; i < PLAYERS; i++ ) 
+        if( m_players[i]->isHuman() )
+            return m_players[i];
+    return NULL;
 }
 
 #include "gamecanvas.moc"
Index: computerplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/computerplayer.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -Lsrc/computerplayer.h -Lsrc/computerplayer.h -u -r1.14 -r1.15
--- src/computerplayer.h
+++ src/computerplayer.h
@@ -30,7 +30,7 @@
 class ComputerPlayer : public Player
 {
     public:
-        ComputerPlayer(Game* game);
+        ComputerPlayer(unsigned int id,Game* game);
         ~ComputerPlayer();
         
 		void init();
Index: canvasplayer.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvasplayer.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -Lsrc/canvasplayer.h -Lsrc/canvasplayer.h -u -r1.7 -r1.8
--- src/canvasplayer.h
+++ src/canvasplayer.h
@@ -52,6 +52,7 @@
         void setName( const QString & name );
         void setCards( CardList* cards );
         
+        CanvasCard* canvasCard( int index );
         void cardPlayed( Card* c );
         CanvasCard* hasCard( int cardid ) const; 
         
Index: canvascard.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvascard.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -Lsrc/canvascard.h -Lsrc/canvascard.h -u -r1.13 -r1.14
--- src/canvascard.h
+++ src/canvascard.h
@@ -39,8 +39,9 @@
         
         void setFrontVisible( bool b );
         void setRotation( int d );
-	void animatedMove();
-	void setDestination( int x, int x );
+        
+        void animatedMove();
+        void setDestination( int x, int x );
 
         
         int rtti() const { return CANVASCARD; }
@@ -50,6 +51,8 @@
           */
         void forbidden();
     
+        void setActive( bool b );
+        
     private:
         void draw( QPainter & p );
         
Index: canvasplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/canvasplayer.cpp,v
retrieving revision 1.21
retrieving revision 1.22
diff -Lsrc/canvasplayer.cpp -Lsrc/canvasplayer.cpp -u -r1.21 -r1.22
--- src/canvasplayer.cpp
+++ src/canvasplayer.cpp
@@ -207,6 +207,18 @@
     }
 }
 
+CanvasCard* CanvasPlayer::canvasCard( int index )
+{
+    if( index < 0 || index >= NUMCARDS )
+        return NULL;
+        
+    CanvasCard* card = m_items[index];
+    if( card->isVisible() )
+        return card;
+    else 
+        return NULL;
+}
+
 CanvasCard* CanvasPlayer::hasCard( int cardid ) const
 {
     for(unsigned int i=0;i<NUMCARDS;i++)
Index: game.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.cpp,v
retrieving revision 1.69
retrieving revision 1.70
diff -Lsrc/game.cpp -Lsrc/game.cpp -u -r1.69 -r1.70
--- src/game.cpp
+++ src/game.cpp
@@ -35,6 +35,8 @@
 #include <kmessagebox.h>
 #include <string.h>
 
+unsigned int Game::def_id=0;
+
 Game::Game(sem_t* sem, QObject *parent )
  : QThread()
 {
@@ -48,9 +50,9 @@
     
     // Create our player objects
     // delete these only in the destructor    
-    m_players[0] = new HumanPlayer( this );
+    m_players[0] = new HumanPlayer( def_id++, this );
     for( i=1;i<PLAYERS;i++)
-        m_players[i] = new ComputerPlayer( this );
+        m_players[i] = new ComputerPlayer( def_id++, this );
     
     updatePlayerNames();
     
@@ -501,7 +503,7 @@
     data->playernames = names;
     data->returncode = NULL;
     data->quitgame = false;
-    
+        
     KApplication::postEvent( m_parent, new QCustomEvent( (QEvent::Type)SCHAFKOPF_EVENT, (void*)data) );
     if( wait )
     {
@@ -511,7 +513,7 @@
             endGame();
 
         ret = data->returncode;
-        
+    
         if( data->cardids )
             delete [] data->cardids;
                 
Index: game.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.h,v
retrieving revision 1.35
retrieving revision 1.36
diff -Lsrc/game.h -Lsrc/game.h -u -r1.35 -r1.36
--- src/game.h
+++ src/game.h
@@ -105,6 +105,8 @@
         void run();
 
     private:
+        static unsigned int def_id;
+        
         sem_t* m_sem;
         bool terminated;
         Player *m_players[PLAYERS];
Index: humanplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/humanplayer.cpp,v
retrieving revision 1.27
retrieving revision 1.28
diff -Lsrc/humanplayer.cpp -Lsrc/humanplayer.cpp -u -r1.27 -r1.28
--- src/humanplayer.cpp
+++ src/humanplayer.cpp
@@ -27,8 +27,8 @@
 
 #include <klocale.h>
 
-HumanPlayer::HumanPlayer(Game* game)
- : Player(game)
+HumanPlayer::HumanPlayer(unsigned int id, Game* game)
+ : Player(id,game)
 {
     m_allowed = NULL;
     m_card = NULL;
Index: computerplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/computerplayer.cpp,v
retrieving revision 1.28
retrieving revision 1.29
diff -Lsrc/computerplayer.cpp -Lsrc/computerplayer.cpp -u -r1.28 -r1.29
--- src/computerplayer.cpp
+++ src/computerplayer.cpp
@@ -27,8 +27,8 @@
 
 #include <kapplication.h>
 
-ComputerPlayer::ComputerPlayer(Game* game)
-	: Player(game)
+ComputerPlayer::ComputerPlayer(unsigned int id,Game* game)
+	: Player(id,game)
 {
 	int i;
 	
Index: player.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/player.h,v
retrieving revision 1.23
retrieving revision 1.24
diff -Lsrc/player.h -Lsrc/player.h -u -r1.23 -r1.24
--- src/player.h
+++ src/player.h
@@ -14,7 +14,7 @@
     public:
         enum { HUMAN = 0, COMPUTER, NETHUMAN };
 		
-		Player(Game* game);
+		Player(unsigned int id, Game* game);
         // this destructor should be virtual
         // but setting it to virtual makes everything
         // crash. Seems to be a good lenz-job ;) ...
@@ -82,7 +82,6 @@
 		bool istTrumpf(Card* card);
         
     private:
-        static unsigned int def_id;
         double m_points;
 		
 		CardList* PlayerCards();
Index: gamecanvas.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.h,v
retrieving revision 1.25
retrieving revision 1.26
diff -Lsrc/gamecanvas.h -Lsrc/gamecanvas.h -u -r1.25 -r1.26
--- src/gamecanvas.h
+++ src/gamecanvas.h
@@ -101,13 +101,17 @@
 
         void contentsMousePressEvent(QMouseEvent*);
         void contentsMouseReleaseEvent(QMouseEvent*);
-                
-    private:
+        void keyPressEvent(QKeyEvent*);
+        void focusInEvent(QFocusEvent*);
+        void focusOutEvent(QFocusEvent*);
+        
+    private:        
         int m_result;
         QPoint getStichPosition( int player );
         int getStichRotation( int player );
-
+        CanvasPlayer* humanPlayer() const;
         
+        QCanvasItemList m_focus_list;
         CanvasPlayer* m_players[PLAYERS];
         CanvasCard* m_stich[PLAYERS];
         

From domseichter at web.de  Sat Feb 19 15:42:09 2005
From: domseichter at web.de (Dominik Seichter)
Date: Sat, 19 Feb 2005 15:42:09 +0100
Subject: [Schafkopf-devel] Freie Neuro Lib
Message-ID: <200502191542.09518.domseichter@web.de>

Habs mir noch ned angeschaut und wird AFAIK a nimmer aktiv weiterentwickelt 
k?nnte aber ganz interessant sein f?r uns.

Wer interesse hat darf sich das mal ansehen:
http://freshmeat.net/projects/sandlib/

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From domseichter at web.de  Sat Feb 19 15:43:29 2005
From: domseichter at web.de (Dominik Seichter)
Date: Sat, 19 Feb 2005 15:43:29 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf (butt-ugly) Tastatursteuerung  Das spielen ist
In-Reply-To: <200502191439.j1JEdc3T012991@sheep.berlios.de>
References: <200502191439.j1JEdc3T012991@sheep.berlios.de>
Message-ID: <200502191543.30026.domseichter@web.de>

Zus?tzlich werden Player IDs jetzt vom Game vergeben und nimmer vom Player. 
Sobald die Player ?bers netzwerk auf verschiedenen Rechnern laufen k?nnen wir 
nimmer in der Player Klasse von 0 hochz?hlen. Daher wird das jetzt in Game 
gemacht.

CU Dom

Am Saturday, 19. February 2005 15:39 schrieb schafkopf-devel at berlios.de:
> Log Message:
> -----------
> (butt-ugly) Tastatursteuerung
>
> Das spielen ist jetzt sch?n konfortabel wenn man ned dauernd rum klicken
> muss!
>
> Rechts/Links verschieben den Focus und Return/Enter "klickt" das aktuell
> gew?hlte Element an. Zuvor muss man nat?rlich den Spielfeld den Tastatur
> Focus geben. Habe ?berlegt ob ich TAB und Shift-TAB zum wechseln nehmen
> soll, aber die Pfeiltasten gefall mir besser.
>
> Die schillernden Farben k?nnt ihr nat?rlich gerne gegen sch?nere
> austauschen. Als Informatiker sollte ich mich bei geschmacksfragen eh
> raushalten.
>
> Modified Files:
> --------------
>     schafkopf:
>         TODO
>     schafkopf/src:
>         canvascard.cpp
>         canvascard.h
>         canvasplayer.cpp
>         canvasplayer.h
>         computerplayer.cpp
>         computerplayer.h
>         game.cpp
>         game.h
>         gamecanvas.cpp
>         gamecanvas.h
>         humanplayer.cpp
>         humanplayer.h
>         player.cpp
>         player.h
>         schafkopfdef.h

-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From schafkopf-devel at berlios.de  Sat Feb 19 15:52:55 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sat, 19 Feb 2005 15:52:55 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf TODO: umlaute entfernt
Message-ID: <200502191452.j1JEqtE1013780@sheep.berlios.de>

Log Message:
-----------
TODO: umlaute entfernt

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.13
retrieving revision 1.14
diff -LTODO -LTODO -u -r1.13 -r1.14
--- TODO
+++ TODO
@@ -1,23 +1,23 @@
-<b>18.02.2005</b>
+<b>19.02.2005</b>
 <pre>
 Fixen:
-- Rufsau nach davonlaufen in allowedCards hinzufgen
+- Rufsau nach davonlaufen in allowedCards hinzufuegen
 
 AI:
 - Solo: Mitspieler schmieren dem Spieler
-- Solo: Spieler spielt seine Trmpfe zu sp???.
-- Computer schmiert auch Ober wenn er nix h???eres hat
-- ???ters Rufspiele spielen
+- Solo: Spieler spielt seine Truempfe zu spaet.
+- Computer schmiert auch Ober wenn er nix hoeheres hat
+- Oefters Rufspiele spielen
 - "Wird eine Farbe das zweite Mal gespielt, so sollte ein AI-Spieler mindestens mit einem Unter stechen, sofern hinter ihm noch ein Gegner kommt." (auf keinen Fall schmieren!!)
 - "Als Spieler nicht die Sau suchen, sondern Trumpf ausspielen"
 - Computer waehlt kein Spiel aus, sondern spielt Eichel-Sticht, wenn er spielen muss (aber nicht will).
 
 neue Features:
-- "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realit??? kann ich es davon abh???gig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralit??? stattfindet." Und dann nur Spiele ausw???lbar machen die h???er sind als die vorher angesagten.
+- "Momentan ist es so, dass ich sofort bei der Spielansage angeben muss, welches Spiel ich zu spielen gedenke. In der Realitaet kann ich es davon abhaengig machen, ob hinter mir noch jemand ein Spiel angemeldet hat. Die exakte Spielauswahl sollte also erst zu dem Zeitpunkt erfolgen, an dem sie auch in der Ralitaet stattfindet." Und dann nur Spiele auswaehlbar machen die hoeher sind als die vorher angesagten.
 - richtige Schafkopfkarten hinzufgen
-- netzwerktransparente Kommunikation (fr neuronales Netzwerk und Netzwerkspiel)
+- netzwerktransparente Kommunikation (fuer neuronales Netzwerk und Netzwerkspiel)
 - speichern und laden von Spielen
-- Trainingsmodus mit "Rckg???gig"-Funktion (auch mehrere Stiche)
+- Trainingsmodus mit "Rueckgaengig"-Funktion (auch mehrere Stiche)
 - "Letzter Stich"-Dialog: Karten so anordnen wie auf dem Spielfeld
 - Kontra, Reh, ...
 </pre>

From domseichter at web.de  Sun Feb 20 12:09:22 2005
From: domseichter at web.de (Dominik Seichter)
Date: Sun, 20 Feb 2005 12:09:22 +0100
Subject: [Schafkopf-devel] Re: Schafkopf
In-Reply-To: <200502192209.15511.post@dominik-lindner.de>
References: <200502192209.15511.post@dominik-lindner.de>
Message-ID: <200502201209.23423.domseichter@web.de>

Hallo Dominik,

Am Saturday, 19. February 2005 22:09 schrieben Sie:
> danke f?r deine Implementierung des Schafkopf-Spiels, danach hab ich schon
> lange gesucht!
Danke. Ich muss aber noch dazu sagen, dass ich das nicht alleine mache sondern 
wir sind im Moment 4 Entwickler.

> Ein paar Kritikpunkte hab ich dennoch anzumerken:
> - Die Spielkarten sind teilweise etwas schlecht zu erkennen (Unter, Ober,
> etc). K?nnte man daf?r Scans von original Karten verwenden, oder spricht da
> etwas dagegen (Copyrights, etc.)?
Kann man. Wir haben im Forum eine kleine HOWTO gebaut wie man sich ein eigenes 
Kartenset erstellen kann: http://www.kbarcode.net/forum/viewtopic.php?t=210

Einfach Karten einscannen und mit geben ist aus Copyright gr?nden nicht 
m?glich soweit ich wei? (ich lasse mich nat?rlich gerne eines besseres 
belehren - leider hat es noch keiner geschafft :-( :-( :-( ).

> - Das Hineinlegen von Karten und das Nehmen des Stichs k?nnte besser
> animiert werden. Das w?rde das Spiel etwas lebendiger machen.
Dar?ber haben wir schon nachgedacht. Im Moment nutzen wir unsere wenige Zeit 
allerdings eher f?r Netzwerk Modus (damit fangen wir geraden an) und KI.

> - Es sollte standardm??ig schon ein Kartentyp eingestellt sein. Es hat mich
> anfangs sehr verwirrt, da? ich keine Karten sehen konnte. Ich hab erstmal
> diverse png Libaries nachinstalliert, weil ich dachte es k?nnte da irgendwo
> der Fehler drin liegen. Hat etwas gedauert bis ich drauf gekommen bin, da?
> man erst einen Kartentyp festlegen mu?.
Hu. Das sollte nat?rlich nicht so sein. Mit welcher version passiert Dir das? 
Ich kann das mit aktueller CVS nicht reproduzieren.

> Ich hab mir den Source-Code noch nicht angeschaut, aber vielleicht k?nntest
> du mir kurz sagen, wie die Spielregeln eigentlich implementiert sind. Gibt
> es daf?r ein einigerma?en abstrahiertes Interface, oder m??te man f?r die
> Ver?nderung der Spielregeln den gesamten Code ver?ndern?
> Mir pers?nlich ist n?mlich das 6-Blatt-Spiel wesentlich lieber. Und ich
> dachte mir, wenn ich mal Zeit hab (und es nicht zu kompliziert ist) k?nnte
> ich ja mal versuchen, Schafkopf um ein 6-Blatt-Spiel zu erweitern. Bisher
> hab ich mit C++ noch nichts im praktischen Sinne gemacht (mein Ding ist
> eher Java), aber das w?re ein gutes Projekt, um C++ im praktischen Einsatz
> kennenzulernen.
Ich denke es sollte nicht allzu kompliziert sein, obwohl ich mich nat?rlich 
leicht tue das zu sagen, da ich den Code ja schon kenne ;).

Ich bin mir jetzt erlich gesagt nicht sicher bei den Regeln des 6-Blatt 
Spieles: Wird das mit 24 oder 32 Karten gespielt?

Falls mit 24 Karten gespielt wird musst CardList::init() ab?ndern, so dass die 
CardList auch wahlweise mit nur 24 Karten initialisiert werden kann und nicht 
immer mit 32.

Auf jeden Fall sollten es eine Option geben, z.B. bool 
Settings::instance()->is6CardGame(), das kannst Du erst mal hardcoden, dass 
es true zur?ck gibt. Die ?nderungen f?r den Preferences Dialog kann dann auch 
ich machen. Das sollte dann an allen relevanten Stellen abgefragt werden,

Da wir bisher faul waren haben wir im ganzen Code folgende Constanten 
verwendet (schafkopfdef.h):

#define PLAYERS   4
#define NUMCARDS  8
#define TURNS     8
#define CARD_CNT  32

Die stimmen beim 6 Blatt spiel nat?rlich nicht mehr. Daher sollten Da 
Variablen draus gemacht werden (am besten Properties von Game w?rde ich 
sagen) die dann auch in Game initialisiert werden (im Konstruktor) je nach 
Settings::instance()->is6CardGame().

Spontan ist das alles was mir einf?llt. Gibt aber sicher noch ein paar Dinge 
an die ich noch nicht gedacht habe, aber da wirst Du ja dann dar?ber 
stolpern.

Wichtig ist noch, Du solltest mit der aktuellen CVS Version arbeiten. Und Du 
solltest die Mailingliste abonnieren 
(https://lists.berlios.de/mailman/listinfo/schafkopf-devel), die wird Dir 
nat?rlich auch gerne bei allen Fragen helfen.

Sobald Du ?nderungen hast kannst Du einfach einen Patch an die Mailingliste 
schicken und wir stellen das so schnell wie m?glich f?r Dich ins CVS.

So, ich hoffe ich hab nichts wichtiges vergessen:
 Happy hacking!

CU Dom
-- 
**********************************************************************
Dominik Seichter - domseichter at web.de
KRename  - http://www.krename.net  - Powerful batch renamer for KDE
KBarcode - http://www.kbarcode.net - Barcode and label printing
KDE Mass Mailer - http://www.kmassmailer.net - Mass mailing for KDE
SchafKopf - http://schafkopf.berlios.de - Schafkopf, a card game,  for KDE
**********************************************************************


From schafkopf-devel at berlios.de  Sun Feb 20 13:52:02 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Sun, 20 Feb 2005 13:52:02 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf unterstrichen ist schner als haessliches
Message-ID: <200502201252.j1KCq2rr029855@sheep.berlios.de>

Log Message:
-----------
unterstrichen ist sch?ner als haessliches weiss, sieht man im winter bei schnee auf dem laptop auch besser

Modified Files:
--------------
    schafkopf/src:
        gamecanvas.cpp

-------------- next part --------------
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.44
retrieving revision 1.45
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.44 -r1.45
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -38,11 +38,15 @@
             : QCanvasText( t, f, c )
         {
             setActive( false );
+            setColor( Qt::yellow );
+
         }
         
         void setActive( bool b )
         {
-            setColor( b ? Qt::white : Qt::yellow );
+            QFont f = font();
+            f.setUnderline( b );
+            setFont( f );
             QCanvasText::setActive( b );
         }
 

From schafkopf-devel at berlios.de  Mon Feb 21 13:43:51 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 21 Feb 2005 13:43:51 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Werden nicht gebraucht.
Message-ID: <200502211243.j1LChpHT018146@sheep.berlios.de>

Log Message:
-----------
Werden nicht gebraucht. Wird jetzt alles in Results gemacht -> weniger doppelter code.

Removed Files:
-------------
    schafkopf/src:
        moneyresults.cpp
        pointresults.cpp
        moneyresults.h
        pointresults.h

-------------- next part --------------
--- src/moneyresults.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2004 by Dominik Seichter                                *
- *   domseichter at web.de                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef MONEYRESULTS_H
-#define MONEYRESULTS_H
-
-#include "results.h"
-
-/**
- at author Dominik Seichter
-*/
-class MoneyResults : virtual public Results
-{
-    public:
-        MoneyResults();
-        double points( Player* player );
-        QString formatedPoints( Player* player );
-};
-
-#endif
--- src/pointresults.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2004 by Dominik Seichter                                *
- *   domseichter at web.de                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#include "pointresults.h"
-#include "player.h"
-#include "game.h"
-#include "gameinfo.h"
-#include "settings.h"
-
-#include <kglobal.h>
-#include <klocale.h>
-
-PointResults::PointResults()
- : Results()
-{
-}
-
-double PointResults::points( Player* player )
-{
-    int m = 0;
-    t_ResultValues* r = Settings::instance()->pointResults();
-    
-    parse();
-
-    if( m_gameinfo->mode() != GameInfo::RUFSPIEL && m_gameinfo->mode() != GameInfo::RAMSCH )
-        m = (int)r->solo; // SOLO = 2
-    else if( m_gameinfo->mode() == GameInfo::RUFSPIEL )
-        m = (int)r->rufspiel;
-        
-    m += m_schneider ? (int)r->schneider : 0;
-    m += m_schwarz ? (int)r->schwarz : 0;
-    m += m_laufende * (int)r->laufende;
-    m = (int)klopfen( player->game()->timesDoubled(), m );
-    
-    if( player == m_gameinfo->spieler() || player == m_gameinfo->mitspieler() )
-        m = (m_points > 60 ? m : m * -1);
-    else
-        m = (m_points > 60 ? m * -1 : m);
-        
-    if( player == m_gameinfo->spieler() && !m_gameinfo->mitspieler() )
-        m *= 3;
-        
-    return (double)m;
-}
-
-QString PointResults::formatedPoints( Player* player )
-{
-    player->setPoints( points( player ) + player->points() );
-    return QString::number( (int)player->points() );
-}
-
--- src/moneyresults.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2004 by Dominik Seichter                                *
- *   domseichter at web.de                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#include "moneyresults.h"
-#include "player.h"
-#include "game.h"
-#include "gameinfo.h"
-#include "settings.h"
-
-#include <kglobal.h>
-#include <klocale.h>
-
-MoneyResults::MoneyResults()
- : Results()
-{
-}
-
-double MoneyResults::points( Player* player )
-{
-    t_ResultValues* r = Settings::instance()->moneyResults();
-    double m = 0.0;
-    
-    parse();
-        
-    if( m_gameinfo->mode() != GameInfo::RUFSPIEL && m_gameinfo->mode() != GameInfo::RAMSCH )
-        m = r->solo; // SOLO = 20cent
-    else if( m_gameinfo->mode() == GameInfo::RUFSPIEL )
-        m = r->rufspiel;
-        
-    m += m_schneider ? r->schneider : 0.0;
-    m += m_schwarz ? r->schwarz : 0.0;
-    m += m_laufende * r->laufende;
-    m = klopfen( player->game()->timesDoubled(), m );
-    
-    if( player == m_gameinfo->spieler() || player == m_gameinfo->mitspieler() )
-        m = (m_points > 60 ? m : m * -1.0);
-    else
-        m = (m_points > 60 ? m * -1.0 : m);
-        
-    if( player == m_gameinfo->spieler() && !m_gameinfo->mitspieler() )
-        m *= 3;
-        
-    return m;
-}
-
-QString MoneyResults::formatedPoints( Player* player )
-{
-    player->setPoints( points( player ) + player->points() );
-    KLocale* locale = KGlobal::locale();
-    return locale->formatMoney( player->points() );
-}
--- src/pointresults.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2004 by Dominik Seichter                                *
- *   domseichter at web.de                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef POINTRESULTS_H
-#define POINTRESULTS_H
-
-#include <results.h>
-
-/**
- at author Dominik Seichter
-*/
-class PointResults : virtual public Results
-{
-    public:
-        PointResults();
-		double points( Player* player );
-        QString formatedPoints( Player* player );
-};
-
-    
-#endif

From schafkopf-devel at berlios.de  Mon Feb 21 13:46:17 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 21 Feb 2005 13:46:17 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf Results ist keine Virtuelle Klasse mehr und
Message-ID: <200502211246.j1LCkHqo018284@sheep.berlios.de>

Log Message:
-----------
Results ist keine Virtuelle Klasse mehr und enth?lt jetzt den Code aus Money- und PointResults.
Results funzt jetzt jetzt auch wenn es keinen Spieler gibt, wie zum Beispiel beim Ramsch.

Auserdem kann jetzt Theoretisch Ramsch gespielt werden. Ist allerdings nicht schwer zu gewinnen, da die KI Versucht so viel zu stechen wie m?glich :).

Modified Files:
--------------
    schafkopf/src:
        Makefile.am
        computerplayer.cpp
        game.cpp
        gamecanvas.cpp
        gameinfo.cpp
        preferencesdlg.cpp
        results.cpp
        results.h
        schafkopf.cpp
        settings.cpp
        settings.h

-------------- next part --------------
Index: settings.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.cpp,v
retrieving revision 1.19
retrieving revision 1.20
diff -Lsrc/settings.cpp -Lsrc/settings.cpp -u -r1.19 -r1.20
--- src/settings.cpp
+++ src/settings.cpp
@@ -19,8 +19,6 @@
  ***************************************************************************/
 #include "settings.h"
 
-#include "moneyresults.h"
-#include "pointresults.h"
 #include "schafkopfdef.h"
 
 #include <kapplication.h>
@@ -188,19 +186,6 @@
     KConfig* config = kapp->config();
     config->setGroup( "SchafKopf" );
     return config->readNumEntry("ResultMode", MONEY );
-}
-
-Results* Settings::results() const
-{
-    QMutexLocker locker( m_mutex );
-    
-    int r = resultsType();
-    if( r == MONEY )
-        return new MoneyResults();
-    else if( r == POINTS )
-        return new PointResults();
-        
-    return NULL;
 }
 
 void Settings::setMoneyResults( const t_ResultValues* r )
Index: schafkopf.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/schafkopf.cpp,v
retrieving revision 1.35
retrieving revision 1.36
diff -Lsrc/schafkopf.cpp -Lsrc/schafkopf.cpp -u -r1.35 -r1.36
--- src/schafkopf.cpp
+++ src/schafkopf.cpp
@@ -384,7 +384,8 @@
         lblDoubled->setText( QString::null );
         return;
     }
-    
+
+
     QString sDoubled;
     for(unsigned int i=0;i<PLAYERS;i++)
     {
Index: results.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/results.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -Lsrc/results.h -Lsrc/results.h -u -r1.6 -r1.7
--- src/results.h
+++ src/results.h
@@ -20,8 +20,10 @@
 #ifndef RESULTS_H
 #define RESULTS_H
 
+#include <qptrlist.h>
 #include <qstring.h>
 
+class Game;
 class GameInfo;
 class Player;
 
@@ -35,26 +37,30 @@
 
 class Results{
     public:
-        virtual ~Results() {}
+        Results();
+        ~Results() {}
         
         void setLaufende( int l ) { m_laufende = l; }
-        void setGameInfo( GameInfo* info ) { m_gameinfo = info; }
-
+        void setGame( Game* game );
+        
         /** get a message of the game results, which can be displayed
           * to the user.
           */
         QString result();
-        virtual double points( Player* player ) = 0;
-        virtual QString formatedPoints( Player* player ) = 0;
+        double points( Player* player );
+        QString formatedPoints( Player* player );
         
         double klopfen(int anzahl, double betrag);
     
     protected:        
-        Results();
-				        
         void parse();
 
+        QPtrList<Player> m_winners;
+        QPtrList<Player> m_losers;
+        
         GameInfo* m_gameinfo;
+        Game* m_game;
+        
         int m_laufende;
         
         int m_points;
Index: Makefile.am
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/Makefile.am,v
retrieving revision 1.16
retrieving revision 1.17
diff -Lsrc/Makefile.am -Lsrc/Makefile.am -u -r1.16 -r1.17
--- src/Makefile.am
+++ src/Makefile.am
@@ -3,10 +3,9 @@
 
 # these are the headers for your project
 noinst_HEADERS = schafkopf.h card.h cardlist.h player.h game.h settings.h \
-			computerplayer.h humanplayer.h gamecanvas.h canvascard.h timer.h stichdlg.h gameinfo.h \
-			canvasplayer.h results.h moneyresults.h pointresults.h openbook.h 		schafkopfdef.h \
-	newgamewizard.h selectgamewizard.h selectgametypebox.h 	selectgamecolorbox.h \
-	preferencesdlg.h
+	computerplayer.h humanplayer.h gamecanvas.h canvascard.h timer.h stichdlg.h gameinfo.h \
+	canvasplayer.h results.h openbook.h schafkopfdef.h newgamewizard.h selectgamewizard.h \
+	selectgametypebox.h selectgamecolorbox.h preferencesdlg.h
 
 # let automoc handle all of the meta source files (moc)
 METASOURCES = AUTO
@@ -25,10 +24,10 @@
 
 # the application source, library search path, and link libraries
 schafkopf_SOURCES = main.cpp schafkopf.cpp card.cpp cardlist.cpp player.cpp \
-			game.cpp settings.cpp computerplayer.cpp humanplayer.cpp gamecanvas.cpp \
-			canvascard.cpp timer.cpp stichdlg.cpp gameinfo.cpp canvasplayer.cpp 		results.cpp \
-	moneyresults.cpp pointresults.cpp openbook.cpp newgamewizard.cpp 	selectgamewizard.cpp \
-	selectgametypebox.cpp selectgamecolorbox.cpp preferencesdlg.cpp
+	game.cpp settings.cpp computerplayer.cpp humanplayer.cpp gamecanvas.cpp \
+	canvascard.cpp timer.cpp stichdlg.cpp gameinfo.cpp canvasplayer.cpp results.cpp \
+	openbook.cpp newgamewizard.cpp selectgamewizard.cpp selectgametypebox.cpp \
+	selectgamecolorbox.cpp preferencesdlg.cpp
 schafkopf_LDFLAGS = $(KDE_RPATH) $(all_libraries)
 schafkopf_LDADD = -lkdegames $(LIB_KDEUI)
 
Index: gamecanvas.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gamecanvas.cpp,v
retrieving revision 1.45
retrieving revision 1.46
diff -Lsrc/gamecanvas.cpp -Lsrc/gamecanvas.cpp -u -r1.45 -r1.46
--- src/gamecanvas.cpp
+++ src/gamecanvas.cpp
@@ -254,6 +254,9 @@
             {
                 m_result = card->card()->id();
                 disconnect( this, SIGNAL(clicked( QCanvasItem* )), this, SLOT(cardClicked(QCanvasItem*)));
+                
+                // be sure that focusOutEvent does not use its parameter
+                focusOutEvent( NULL );
                 EXIT_LOOP();
             }
         }
Index: computerplayer.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/computerplayer.cpp,v
retrieving revision 1.29
retrieving revision 1.30
diff -Lsrc/computerplayer.cpp -Lsrc/computerplayer.cpp -u -r1.29 -r1.30
--- src/computerplayer.cpp
+++ src/computerplayer.cpp
@@ -109,7 +109,9 @@
 			if(m_game->findIndex(mitspieler)==m_game->gameInfo()->spieler())
 				break;
 	}
-	else if(m_game->gameInfo()->mode()!=GameInfo::RUFSPIEL && m_game->gameInfo()->spieler()!=this)
+	else if(m_game->gameInfo()->mode()!=GameInfo::RUFSPIEL && 
+            m_game->gameInfo()->mode()!=GameInfo::RAMSCH &&
+            m_game->gameInfo()->spieler()!=this)
 		mitspieler=m_game->gameInfo()->spieler()->id();
 	else
 		mitspieler=-1;
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.19
retrieving revision 1.20
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.19 -r1.20
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -87,7 +87,13 @@
     names << m_p4_name->text();
     s->setPlayerNames( names );
     
-    s->setNoGame( m_radioThrowAway->isChecked() ? Settings::NOGAME_NEUGEBEN : Settings::NOGAME_ALTERSPIELT );
+    if( m_radioThrowAway->isChecked() )
+        s->setNoGame( Settings::NOGAME_NEUGEBEN );
+    else if ( m_radioForcedGame->isChecked() )
+        s->setNoGame( Settings::NOGAME_ALTERSPIELT );
+    else if( m_radioRamsch->isChecked() )
+        s->setNoGame( Settings::NOGAME_RAMSCH );
+        
     s->setDoublerHasToPlay( m_checkDoublerPlays->isChecked() );
     
     s->setDoubleNextGame( m_checkDoubleNextGame->isChecked() );
@@ -138,8 +144,8 @@
     m_radioThrowAway = new QRadioButton( i18n("&Throw cards together and give new ones."), group );
     m_radioForcedGame = new QRadioButton( i18n("The player who has the Eichel &Ober has to play."), group );
     m_radioRamsch = new QRadioButton( i18n("Play Ramsch (not available yet)"), group );
+    
     QToolTip::add( m_radioRamsch, i18n("The aim when playing a Ramsch is to make no tricks. The player who made the most points is the sole loser.") );
-    m_radioRamsch->setEnabled( false );
     m_checkDoublerPlays = new QCheckBox ( i18n("The &last player who has doubled has to play."), group );
     QToolTip::add( m_checkDoublerPlays, i18n("The last player who has doubled has to play. If no one has doubled the above rule takes effect.") );
     m_checkDoubleNextGame = new QCheckBox ( i18n("&Double next game when cards were thrown together."), group );
@@ -150,8 +156,10 @@
     // load data from configuration
     if( Settings::instance()->noGame() == Settings::NOGAME_ALTERSPIELT )
         m_radioForcedGame->setChecked( true );
-    else
+    else if( Settings::instance()->noGame() == Settings::NOGAME_NEUGEBEN )
         m_radioThrowAway->setChecked( true );
+    else if( Settings::instance()->noGame() == Settings::NOGAME_RAMSCH )
+        m_radioRamsch->setChecked( true );
         
     m_checkDoublerPlays->setChecked( Settings::instance()->doublerHasToPlay() );
     
@@ -160,6 +168,7 @@
     // connections
     connect( m_radioThrowAway, SIGNAL( clicked() ), this, SLOT( enableControls() ) );
     connect( m_radioForcedGame, SIGNAL( clicked() ), this, SLOT( enableControls() ) );
+    connect( m_radioRamsch, SIGNAL( clicked() ), this, SLOT( enableControls() ) );
 }
 
 void PreferencesDlg::addPageResults()
Index: game.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.cpp,v
retrieving revision 1.70
retrieving revision 1.71
diff -Lsrc/game.cpp -Lsrc/game.cpp -u -r1.70 -r1.71
--- src/game.cpp
+++ src/game.cpp
@@ -302,18 +302,18 @@
 
 void Game::gameResults()
 {
-    Results* r = Settings::instance()->results();
-    r->setLaufende( m_laufende );
-    r->setGameInfo( &m_gameinfo );
+    Results r;
+    r.setLaufende( m_laufende );
+    r.setGame( this );
+    
     for( unsigned int i=0;i<PLAYERS;i++)
     {
-        postEvent( PlayerResults, m_players[i]->id(), 0, r->formatedPoints(m_players[i]), true );
+        postEvent( PlayerResults, m_players[i]->id(), 0, r.formatedPoints(m_players[i]), true );
         // emit playerResult( m_players[i]->name(), r->formatedPoints(m_players[i])  );
     }
       
-    postEvent( InfoMessage, 0, 0, r->result(), true );
+    postEvent( InfoMessage, 0, 0, r.result(), true );
     //m_canvas->information( r->result() );
-    delete r;
     m_timesThrownTogether = 0;
     
     // the game is over, so the GameInfo structure is not
@@ -442,6 +442,15 @@
                 delete info;
                 return true;
             }
+    }
+    else if( Settings::instance()->noGame() == Settings::NOGAME_RAMSCH )
+    {
+        postEvent( InfoMessage, 0, 0, i18n("No one wants to play.\nRamsch will be played."), true );
+        m_gameinfo.setSpieler( NULL );
+        m_gameinfo.setMitspieler( NULL );
+        m_gameinfo.setMode( GameInfo::RAMSCH );
+        m_gameinfo.setColor( Card::NOCOLOR );
+        return true;
     }
     
     return false;
Index: results.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/results.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -Lsrc/results.cpp -Lsrc/results.cpp -u -r1.9 -r1.10
--- src/results.cpp
+++ src/results.cpp
@@ -23,15 +23,19 @@
 #include "schafkopfdef.h"
 
 #include "cardlist.h"
+#include "game.h"
 #include "gameinfo.h"
 #include "player.h"
+#include "settings.h"
 
+#include <kglobal.h>
 #include <klocale.h>
 
 Results::Results()
 {
     m_laufende = 0;
     m_gameinfo = NULL;
+    m_game = NULL;
     m_parsed = false;
 }
 
@@ -43,18 +47,28 @@
     QString s;
     QString schneider = m_schneider ? i18n(" schneider" ) : QString::null;
     QString schwarz = m_schwarz ? i18n(" no-trick") : QString::null;
+    Player* winner = m_gameinfo->spieler();
+    bool won = m_points > 60;
     
-    if( m_points > 60 )
-        s = m_gameinfo->spieler()->name() + QString(i18n(" wins with %1 points%2.")).arg( m_points ).arg( schneider + schwarz );
+    if( !winner )
+    {
+        won = m_winners.count() == 1;
+        winner = won ? m_winners.at(0) : m_losers.at(0);
+    }
+    
+    if( won )
+        s = winner->name() + QString(i18n(" wins with %1 points%2."))
+            .arg( m_points ).arg( schneider + schwarz );
     else
-        s = m_gameinfo->spieler()->name() + QString(i18n(" loses with %1 points%2.") ).arg( m_points ).arg( schneider + schwarz );
+        s = winner->name() + QString(i18n(" loses with %1 points%2.") )
+            .arg( m_points ).arg( schneider + schwarz );
     
     if( m_laufende )
     {
         if( positive )
-            s += "\n" + m_gameinfo->spieler()->name() + QString( i18n(" got %1 cards in a row.").arg( m_laufende ) );
+            s += "\n" + winner->name() + QString( i18n(" got %1 cards in a row.").arg( m_laufende ) );
         else
-            s += "\n" + m_gameinfo->spieler()->name() + QString( i18n(" played without %1 cards in a row.").arg( m_laufende ) );
+            s += "\n" + winner->name() + QString( i18n(" played without %1 cards in a row.").arg( m_laufende ) );
     }
     
     return s;
@@ -62,28 +76,81 @@
 
 void Results::parse()
 {
+    int i;
+
     if( m_parsed )
         return;
         
-    CardList stiche( *(m_gameinfo->spieler()->stiche()) );
-    if( m_gameinfo->mitspieler() )
-        stiche.appendList( m_gameinfo->mitspieler()->stiche() );
-    
-    m_points = stiche.points();
-    m_schwarz = ( stiche.isEmpty() || stiche.count() == NUMCARDS * PLAYERS );
-    m_schneider = (m_points < 31 || m_points > 90 );
-
-    m_parsed = true;
-    
-    // ab 2 laufende bei wenz und geier
-    if( m_gameinfo->mode() == GameInfo::GEIER || m_gameinfo->mode() == GameInfo::WENZ )
-        m_laufende = ( m_laufende >= 2 || m_laufende <= -2 ) ? m_laufende : 0;
-    // sonst ab 3 laufenden
-    else if( m_gameinfo->mode() == GameInfo::STICHT || m_gameinfo->mode() == GameInfo::RAMSCH 
-          || m_gameinfo->mode() == GameInfo::DACHS || m_gameinfo->mode() == GameInfo::RUFSPIEL )
-        m_laufende = ( m_laufende >= 3 || m_laufende <= -3 ) ? m_laufende : 0;
-    
-    m_laufende = m_laufende < 0 ? m_laufende * -1 : m_laufende;
+    if( m_gameinfo->mode() == GameInfo::RAMSCH )
+    {
+        // suche den spieler mit den meisten punkten, denn er hat verloren
+        // oder wenn er alle stiche hat, dann hat er mit durchmarsch gewonnen
+        int highest = 0;
+        for( i=0;i<PLAYERS;i++ )
+            if( m_game->findIndex( i )->stiche()->points() > m_game->findIndex( highest )->stiche()->points() )
+                highest = i;
+
+        m_points = m_game->findIndex( highest )->stiche()->points();
+        if( m_game->findIndex( highest )->stiche()->count() == TURNS )
+        {
+            m_winners.append( m_game->findIndex( highest ) );
+            for( i=0;i<PLAYERS;i++ )
+                if( i!=highest )
+                    m_losers.append( m_game->findIndex( i ) );
+        }
+        else
+        {
+            m_losers.append( m_game->findIndex( highest ) );
+            for( i=0;i<PLAYERS;i++ )
+                if( i!=highest )
+                    m_winners.append( m_game->findIndex( i ) );
+        }
+    }
+    else
+    {
+        CardList stiche( *(m_gameinfo->spieler()->stiche()) );
+        if( m_gameinfo->mitspieler() )
+            stiche.appendList( m_gameinfo->mitspieler()->stiche() );
+       
+        m_points = stiche.points();
+        m_schwarz = ( stiche.isEmpty() || stiche.count() == NUMCARDS * PLAYERS );
+        m_schneider = (m_points < 31 || m_points > 90 );
+    
+        if( m_points > 60 )
+        {
+            m_winners.append( m_gameinfo->spieler() );
+            if( m_gameinfo->mitspieler() )
+                m_winners.append( m_gameinfo->mitspieler() );
+                
+            for( i=0;i<PLAYERS;i++ )
+                if( m_game->findIndex( i ) != m_gameinfo->spieler() && 
+                    m_game->findIndex( i ) != m_gameinfo->mitspieler() )
+                    m_losers.append( m_game->findIndex( i ) );
+        }
+        else
+        {
+            m_losers.append( m_gameinfo->spieler() );
+            if( m_gameinfo->mitspieler() )
+                m_losers.append( m_gameinfo->mitspieler() );
+                
+            for( i=0;i<PLAYERS;i++ )
+                if( m_game->findIndex( i ) != m_gameinfo->spieler() && 
+                    m_game->findIndex( i ) != m_gameinfo->mitspieler() )
+                    m_winners.append( m_game->findIndex( i ) );
+        }
+        
+        m_parsed = true;
+        
+        // ab 2 laufende bei wenz und geier
+        if( m_gameinfo->mode() == GameInfo::GEIER || m_gameinfo->mode() == GameInfo::WENZ )
+            m_laufende = ( m_laufende >= 2 || m_laufende <= -2 ) ? m_laufende : 0;
+        // sonst ab 3 laufenden
+        else if( m_gameinfo->mode() == GameInfo::STICHT || m_gameinfo->mode() == GameInfo::RAMSCH 
+                || m_gameinfo->mode() == GameInfo::DACHS || m_gameinfo->mode() == GameInfo::RUFSPIEL )
+            m_laufende = ( m_laufende >= 3 || m_laufende <= -3 ) ? m_laufende : 0;
+        
+        m_laufende = m_laufende < 0 ? m_laufende * -1 : m_laufende;
+    }
 }
 
 double Results::klopfen(int anzahl, double betrag)
@@ -92,5 +159,66 @@
         return betrag; 
     else 
         return klopfen(anzahl-1, betrag)*2.0; 
+}
+
+void Results::setGame( Game* game )
+{ 
+    m_game = game; 
+    m_gameinfo = game->gameInfo();
+}
+
+double Results::points( Player* player )
+{
+    t_ResultValues* r = Settings::instance()->resultsType() == Settings::MONEY ? 
+                    Settings::instance()->moneyResults() :
+                    Settings::instance()->pointResults();                    
+    double m = 0.0;
+    
+    parse();
+        
+    if( m_gameinfo->mode() != GameInfo::RUFSPIEL && m_gameinfo->mode() != GameInfo::RAMSCH )
+        m = r->solo; // SOLO = 20cent
+    else if( m_gameinfo->mode() == GameInfo::RUFSPIEL )
+        m = r->rufspiel;
+        
+    m += m_schneider ? r->schneider : 0.0;
+    m += m_schwarz ? r->schwarz : 0.0;
+    m += m_laufende * r->laufende;
+    m = klopfen( player->game()->timesDoubled(), m );
+    
+    //if( player == m_gameinfo->spieler() || player == m_gameinfo->mitspieler() )
+    if( !m_winners.containsRef( player ) )
+        m *= -1.0;
+        
+    //if( player == m_gameinfo->spieler() && !m_gameinfo->mitspieler() )
+    //        m *= 3;
+
+    if( m_winners.count() == 1 )
+    {
+        if( m_winners.containsRef( player ) )
+            m *= (PLAYERS - m_winners.count());
+    }
+    else if( m_winners.count() == PLAYERS - 1 )
+    {
+        if( !m_winners.containsRef( player ) )
+            m *= (PLAYERS - m_winners.count());
+    }
+       
+    return m;
+}
+
+QString Results::formatedPoints( Player* player )
+{
+    player->setPoints( points( player ) + player->points() );
+    
+    if( Settings::instance()->resultsType() == Settings::MONEY )
+    {
+        KLocale* locale = KGlobal::locale();
+        return locale->formatMoney( player->points() );
+    }
+    else
+    {
+        return QString::number( (int)player->points() );    
+    }
 }
 
Index: gameinfo.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/gameinfo.cpp,v
retrieving revision 1.19
retrieving revision 1.20
diff -Lsrc/gameinfo.cpp -Lsrc/gameinfo.cpp -u -r1.19 -r1.20
--- src/gameinfo.cpp
+++ src/gameinfo.cpp
@@ -148,6 +148,10 @@
 {
     t_AllowedGames* allowed = NULL;
     
+    // it is never allowed to decide to play Ramsch
+    if( mode == GameInfo::RAMSCH )
+        return false;
+        
     if( mode==GameInfo::RUFSPIEL ) 
     {
         if( cards->contains( color, Card::SAU ) || color == Card::HERZ )
@@ -310,6 +314,15 @@
 
 int GameInfo::laufende()
 {
+#warning "Im Ramsch werden keine Laufenden gezaehlt!"
+    if( m_mode == RAMSCH )
+        return 0;
+        
+    /** TODO: jeder spieler sollte eine laufende property haben und
+      * selst z??hlen wie viele laufende er hat.
+      * danach k??nnen diese in results einfach addiert werden
+      */
+        
     unsigned int i = 0;
     int l = 0;
     CardList* all = new CardList();
Index: settings.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.h,v
retrieving revision 1.15
retrieving revision 1.16
diff -Lsrc/settings.h -Lsrc/settings.h -u -r1.15 -r1.16
--- src/settings.h
+++ src/settings.h
@@ -67,7 +67,7 @@
     Q_OBJECT
     public:
         enum { MONEY, POINTS };
-        enum { NOGAME_NEUGEBEN, NOGAME_ALTERSPIELT };
+        enum { NOGAME_NEUGEBEN, NOGAME_ALTERSPIELT, NOGAME_RAMSCH };
         
         static Settings* instance();
         
@@ -84,8 +84,7 @@
         
         void setResultsType( int r );
         int resultsType() const;
-        Results* results() const;
-
+        
         void setNoGame( int e );
         /** returns what has to happen when no player wants to play
           */

From schafkopf-devel at berlios.de  Mon Feb 21 13:50:38 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 21 Feb 2005 13:50:38 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf code im cvs sollte sich kompilieren lassen...
Message-ID: <200502211250.j1LCocme018581@sheep.berlios.de>

Log Message:
-----------
code im cvs sollte sich kompilieren lassen...

Modified Files:
--------------
    schafkopf/src:
        game.cpp

-------------- next part --------------
Index: game.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/game.cpp,v
retrieving revision 1.71
retrieving revision 1.72
diff -Lsrc/game.cpp -Lsrc/game.cpp -u -r1.71 -r1.72
--- src/game.cpp
+++ src/game.cpp
@@ -25,8 +25,6 @@
 #include "gamecanvas.h"
 #include "gameinfo.h"
 #include "results.h"
-#include "moneyresults.h"
-#include "pointresults.h"
 
 #include "settings.h"
 

From schafkopf-devel at berlios.de  Mon Feb 21 15:28:15 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 21 Feb 2005 15:28:15 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf TODO: zeilenumbruch auf hp
Message-ID: <200502211428.j1LESFoW030672@sheep.berlios.de>

Log Message:
-----------
TODO: zeilenumbruch auf hp

Modified Files:
--------------
    schafkopf:
        TODO

-------------- next part --------------
Index: TODO
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/TODO,v
retrieving revision 1.14
retrieving revision 1.15
diff -LTODO -LTODO -u -r1.14 -r1.15
--- TODO
+++ TODO
@@ -1,5 +1,5 @@
 <b>19.02.2005</b>
-<pre>
+<pre width="60">
 Fixen:
 - Rufsau nach davonlaufen in allowedCards hinzufuegen
 

From schafkopf-devel at berlios.de  Mon Feb 21 16:38:18 2005
From: schafkopf-devel at berlios.de (schafkopf-devel at berlios.de)
Date: Mon, 21 Feb 2005 16:38:18 +0100
Subject: [Schafkopf-devel] Commit Report - Schafkopf bugfixes - ergebnis wird wieder korrekt
Message-ID: <200502211538.j1LFcIrC025836@sheep.berlios.de>

Log Message:
-----------
bugfixes - ergebnis wird wieder korrekt berechnet

Modified Files:
--------------
    schafkopf/src:
        preferencesdlg.cpp
        preferencesdlg.h
        results.cpp
        results.h
        settings.cpp
        settings.h

-------------- next part --------------
Index: results.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/results.cpp,v
retrieving revision 1.10
retrieving revision 1.11
diff -Lsrc/results.cpp -Lsrc/results.cpp -u -r1.10 -r1.11
--- src/results.cpp
+++ src/results.cpp
@@ -33,10 +33,20 @@
 
 Results::Results()
 {
-    m_laufende = 0;
     m_gameinfo = NULL;
     m_game = NULL;
-    m_parsed = false;
+    
+    init();
+}
+
+void Results::init()
+{
+    m_laufende = 0;
+    m_schneider = false;
+    m_schwarz = false;
+    
+    m_winners.clear();
+    m_losers.clear();
 }
 
 QString Results::result()
@@ -78,8 +88,7 @@
 {
     int i;
 
-    if( m_parsed )
-        return;
+    init();
         
     if( m_gameinfo->mode() == GameInfo::RAMSCH )
     {
@@ -138,9 +147,7 @@
                     m_game->findIndex( i ) != m_gameinfo->mitspieler() )
                     m_winners.append( m_game->findIndex( i ) );
         }
-        
-        m_parsed = true;
-        
+                
         // ab 2 laufende bei wenz und geier
         if( m_gameinfo->mode() == GameInfo::GEIER || m_gameinfo->mode() == GameInfo::WENZ )
             m_laufende = ( m_laufende >= 2 || m_laufende <= -2 ) ? m_laufende : 0;
@@ -180,6 +187,8 @@
         m = r->solo; // SOLO = 20cent
     else if( m_gameinfo->mode() == GameInfo::RUFSPIEL )
         m = r->rufspiel;
+    else if( m_gameinfo->mode() == GameInfo::RAMSCH )
+        m = r->ramsch;
         
     m += m_schneider ? r->schneider : 0.0;
     m += m_schwarz ? r->schwarz : 0.0;
@@ -196,12 +205,12 @@
     if( m_winners.count() == 1 )
     {
         if( m_winners.containsRef( player ) )
-            m *= (PLAYERS - m_winners.count());
+            m *= (PLAYERS - 1);
     }
     else if( m_winners.count() == PLAYERS - 1 )
     {
         if( !m_winners.containsRef( player ) )
-            m *= (PLAYERS - m_winners.count());
+            m *= m_winners.count();
     }
        
     return m;
Index: preferencesdlg.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.h,v
retrieving revision 1.15
retrieving revision 1.16
diff -Lsrc/preferencesdlg.h -Lsrc/preferencesdlg.h -u -r1.15 -r1.16
--- src/preferencesdlg.h
+++ src/preferencesdlg.h
@@ -91,12 +91,14 @@
         KDoubleNumInput* m_money_lauf;
         KDoubleNumInput* m_money_notrick;
         KDoubleNumInput* m_money_schneider;
+        KDoubleNumInput* m_money_ramsch;
         
         KIntNumInput* m_point_solo;
         KIntNumInput* m_point_call;
         KIntNumInput* m_point_lauf;
         KIntNumInput* m_point_notrick;
         KIntNumInput* m_point_schneider;
+        KIntNumInput* m_point_ramsch;
 };
 
 #endif
Index: settings.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.h,v
retrieving revision 1.16
retrieving revision 1.17
diff -Lsrc/settings.h -Lsrc/settings.h -u -r1.16 -r1.17
--- src/settings.h
+++ src/settings.h
@@ -31,6 +31,7 @@
     double laufende;
     double schwarz;
     double schneider;
+    double ramsch;
 };
 
 /** a datatype defining which games are allowed to be 
Index: settings.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/settings.cpp,v
retrieving revision 1.20
retrieving revision 1.21
diff -Lsrc/settings.cpp -Lsrc/settings.cpp -u -r1.20 -r1.21
--- src/settings.cpp
+++ src/settings.cpp
@@ -199,6 +199,7 @@
     config->writeEntry( "Laufende", r->laufende );
     config->writeEntry( "Schneider", r->schneider );
     config->writeEntry( "Schwarz", r->schwarz );
+    config->writeEntry( "Ramsch", r->ramsch );
     config->sync();
 }
 
@@ -213,6 +214,7 @@
     config->writeEntry( "Laufende", (int)r->laufende );
     config->writeEntry( "Schneider", (int)r->schneider );
     config->writeEntry( "Schwarz", (int)r->schwarz );
+    config->writeEntry( "Ramsch", (int)r->ramsch );
     config->sync();
 }
 
@@ -228,6 +230,7 @@
     r->laufende = config->readDoubleNumEntry( "Laufende", 0.1 );
     r->schneider = config->readDoubleNumEntry( "Schneider", 0.1 );
     r->schwarz = config->readDoubleNumEntry( "Schwarz", 0.1 );
+    r->ramsch = config->readDoubleNumEntry( "Ramsch", 0.2 );
     return r;    
 }
 
@@ -243,6 +246,7 @@
     r->laufende = config->readNumEntry( "Laufende", 1 );
     r->schneider = config->readNumEntry( "Schneider", 1 );
     r->schwarz = config->readNumEntry( "Schwarz", 1 );
+    r->ramsch = config->readNumEntry( "Ramsch", 1 );
     return r;    
 }
 
Index: results.h
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/results.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -Lsrc/results.h -Lsrc/results.h -u -r1.7 -r1.8
--- src/results.h
+++ src/results.h
@@ -51,9 +51,12 @@
         QString formatedPoints( Player* player );
         
         double klopfen(int anzahl, double betrag);
-    
-    protected:        
+
+    private:
+        void init();
         void parse();
+    
+    private:        
 
         QPtrList<Player> m_winners;
         QPtrList<Player> m_losers;
@@ -66,9 +69,6 @@
         int m_points;
         bool m_schneider;
         bool m_schwarz;
-        
-    private:
-        bool m_parsed;
 };
 
 #endif
Index: preferencesdlg.cpp
===================================================================
RCS file: /cvsroot/schafkopf/schafkopf/src/preferencesdlg.cpp,v
retrieving revision 1.20
retrieving revision 1.21
diff -Lsrc/preferencesdlg.cpp -Lsrc/preferencesdlg.cpp -u -r1.20 -r1.21
--- src/preferencesdlg.cpp
+++ src/preferencesdlg.cpp
@@ -71,6 +71,7 @@
     r.laufende = m_money_lauf->value();
     r.schneider = m_money_schneider->value();
     r.schwarz = m_money_notrick->value();
+    r.ramsch = m_money_ramsch->value();
     s->setMoneyResults( &r );
     
     r.rufspiel = m_point_call->value();
@@ -78,6 +79,7 @@
     r.laufende = m_point_lauf->value();
     r.schneider = m_point_schneider->value();
     r.schwarz = m_point_notrick->value();
+    r.ramsch = m_point_ramsch->value();
     s->setPointResults( &r );
    
     QStringList names; 
@@ -143,9 +145,9 @@
     QVButtonGroup* group = new QVButtonGroup( i18n("No one wants to play:"), box, "group" );
     m_radioThrowAway = new QRadioButton( i18n("&Throw cards together and give new ones."), group );
     m_radioForcedGame = new QRadioButton( i18n("The player who has the Eichel &Ober has to play."), group );
-    m_radioRamsch = new QRadioButton( i18n("Play Ramsch (not available yet)"), group );
+    m_radioRamsch = new QRadioButton( i18n("Play Ramsch"), group );
     
-    QToolTip::add( m_radioRamsch, i18n("The aim when playing a Ramsch is to make no tricks. The player who made the most points is the sole loser.") );
+    QToolTip::add( m_radioRamsch, i18n("The aim when playing a Ramsch is to make no tricks. The player who made the most points is the sole loser. If you make all tricks you can win, too.") );
     m_checkDoublerPlays = new QCheckBox ( i18n("The &last player who has doubled has to play."), group );
     QToolTip::add( m_checkDoublerPlays, i18n("The last player who has doubled has to play. If no one has doubled the above rule takes effect.") );
     m_checkDoubleNextGame = new QCheckBox ( i18n("&Double next game when cards were thrown together."), group );
@@ -221,11 +223,16 @@
     m_money_schneider->setLabel( i18n("Schneider:"), AlignLeft | AlignVCenter );
     m_money_schneider->setSuffix( locale->currencySymbol() );
     
+    m_money_ramsch = new KDoubleNumInput( m_money_schneider, 0.0, 100.00, r->ramsch, 0.10, 2, box, "m_money_ramsch" );
+    m_money_ramsch->setLabel( i18n("Ramsch:"), AlignLeft | AlignVCenter );
+    m_money_ramsch->setSuffix( locale->currencySymbol() );
+    
     layout->addWidget( m_money_call );    
     layout->addWidget( m_money_solo );
     layout->addWidget( m_money_lauf );
     layout->addWidget( m_money_notrick );
     layout->addWidget( m_money_schneider );
+    layout->addWidget( m_money_ramsch );
     layout->addItem( spacer );
     
     delete r;
@@ -262,12 +269,18 @@
     m_point_schneider->setLabel( i18n("Schneider:"), AlignLeft | AlignVCenter );
     m_point_schneider->setMinValue( 0 );
     m_point_schneider->setMaxValue( 100 );
+
+    m_point_ramsch = new KIntNumInput( m_point_schneider, (int)r->ramsch, box, 10, "m_point_ramsch" );
+    m_point_ramsch->setLabel( i18n("Ramsch:"), AlignLeft | AlignVCenter );
+    m_point_ramsch->setMinValue( 0 );
+    m_point_ramsch->setMaxValue( 100 );
     
     layout->addWidget( m_point_call );    
     layout->addWidget( m_point_solo );
     layout->addWidget( m_point_lauf );
     layout->addWidget( m_point_notrick );
     layout->addWidget( m_point_schneider );
+    layout->addWidget( m_point_ramsch );
     layout->addItem( spacer );
     
     delete r;

